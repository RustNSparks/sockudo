<!doctype html>
<html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Mochawesome Report</title><link rel="stylesheet" href="assets/app.css"/></head><body data-raw="{&quot;stats&quot;:{&quot;suites&quot;:32,&quot;tests&quot;:67,&quot;passes&quot;:38,&quot;pending&quot;:0,&quot;failures&quot;:29,&quot;start&quot;:&quot;2025-08-10T08:19:37.807Z&quot;,&quot;end&quot;:&quot;2025-08-10T08:20:34.873Z&quot;,&quot;duration&quot;:57066,&quot;testsRegistered&quot;:67,&quot;passPercent&quot;:56.71641791044776,&quot;pendingPercent&quot;:0,&quot;other&quot;:0,&quot;hasOther&quot;:false,&quot;skipped&quot;:0,&quot;hasSkipped&quot;:false},&quot;results&quot;:[{&quot;uuid&quot;:&quot;e9887036-9008-46a1-af29-a62ac6fef275&quot;,&quot;title&quot;:&quot;&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;4cad1cb4-d92e-4c32-bfff-bd7b95c57ff8&quot;,&quot;title&quot;:&quot;Authentication Tests&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/auth.test.js&quot;,&quot;file&quot;:&quot;/tests/auth.test.js&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before all\&quot; hook in \&quot;Authentication Tests\&quot;&quot;,&quot;fullTitle&quot;:&quot;Authentication Tests \&quot;before all\&quot; hook in \&quot;Authentication Tests\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1006,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Start our own auth server on a different port for testing auth behavior\nauthServer = new AuthServer({ port: 3011 });\nawait authServer.start();\nawait TestUtils.wait(1000);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9768933e-e615-4e79-afe3-d3f838abb3ef&quot;,&quot;parentUUID&quot;:&quot;4cad1cb4-d92e-4c32-bfff-bd7b95c57ff8&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;\&quot;before each\&quot; hook in \&quot;Authentication Tests\&quot;&quot;,&quot;fullTitle&quot;:&quot;Authentication Tests \&quot;before each\&quot; hook in \&quot;Authentication Tests\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = new TestClient({ \n    authEndpoint: `http://localhost:3011/pusher/auth`\n});\nawait client.connect();\nauthServer.clearAuthRequests();&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0052c7d5-2b8b-4386-8aab-08ae0f064fc2&quot;,&quot;parentUUID&quot;:&quot;4cad1cb4-d92e-4c32-bfff-bd7b95c57ff8&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[{&quot;title&quot;:&quot;\&quot;after all\&quot; hook in \&quot;Authentication Tests\&quot;&quot;,&quot;fullTitle&quot;:&quot;Authentication Tests \&quot;after all\&quot; hook in \&quot;Authentication Tests\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:0,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;if (authServer) {\n    await authServer.stop();\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;eb05139f-4bfa-457c-b6e6-6a320a303cc7&quot;,&quot;parentUUID&quot;:&quot;4cad1cb4-d92e-4c32-bfff-bd7b95c57ff8&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;\&quot;after each\&quot; hook in \&quot;Authentication Tests\&quot;&quot;,&quot;fullTitle&quot;:&quot;Authentication Tests \&quot;after each\&quot; hook in \&quot;Authentication Tests\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:0,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;if (client &amp;&amp; client.isConnected()) {\n    await client.disconnect();\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;f172b669-4609-407c-a4d3-427c81ad28ec&quot;,&quot;parentUUID&quot;:&quot;4cad1cb4-d92e-4c32-bfff-bd7b95c57ff8&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;9b0daae8-3086-4ed8-a55f-b33bda839963&quot;,&quot;title&quot;:&quot;Private Channel Authentication&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/auth.test.js&quot;,&quot;file&quot;:&quot;/tests/auth.test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should authenticate successfully with valid signature&quot;,&quot;fullTitle&quot;:&quot;Authentication Tests Private Channel Authentication should authenticate successfully with valid signature&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:11,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = &#x27;private-auth-test&#x27;;\n\nconst { channel } = await client.subscribe(channelName);\n\nexpect(channel).to.exist;\nexpect(client.getChannel(channelName)).to.equal(channel);\n\n// Verify auth request was made\nconst authRequests = authServer.getAuthRequests();\nexpect(authRequests).to.have.lengthOf(1);\nexpect(authRequests[0].channel_name).to.equal(channelName);\nexpect(authRequests[0].socket_id).to.equal(client.getSocketId());&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e85b64e6-413e-4e70-9c66-3e6821dd0059&quot;,&quot;parentUUID&quot;:&quot;9b0daae8-3086-4ed8-a55f-b33bda839963&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail authentication with invalid signature&quot;,&quot;fullTitle&quot;:&quot;Authentication Tests Private Channel Authentication should fail authentication with invalid signature&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5008,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Create a custom auth server that returns invalid signatures\nconst invalidAuthServer = new AuthServer({ port: 3006 });\ninvalidAuthServer.generateAuthSignature = () =&gt; &#x27;invalid-signature&#x27;;\nawait invalidAuthServer.start();\n\nconst clientWithInvalidAuth = new TestClient({\n    authEndpoint: &#x27;http://localhost:3006/pusher/auth&#x27;\n});\n\ntry {\n    await clientWithInvalidAuth.connect();\n    await clientWithInvalidAuth.subscribe(&#x27;private-invalid-auth&#x27;);\n    expect.fail(&#x27;Should have thrown an error&#x27;);\n} catch (error) {\n    expect(error).to.be.an(&#x27;error&#x27;);\n} finally {\n    await clientWithInvalidAuth.disconnect();\n    await invalidAuthServer.stop();\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d5eae23b-2e28-4561-84ae-ba133a9ef391&quot;,&quot;parentUUID&quot;:&quot;9b0daae8-3086-4ed8-a55f-b33bda839963&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should authenticate multiple private channels independently&quot;,&quot;fullTitle&quot;:&quot;Authentication Tests Private Channel Authentication should authenticate multiple private channels independently&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channels = [&#x27;private-test-1&#x27;, &#x27;private-test-2&#x27;, &#x27;private-test-3&#x27;];\n\nfor (const channelName of channels) {\n    const { channel } = await client.subscribe(channelName);\n    expect(channel).to.exist;\n    expect(client.getChannel(channelName)).to.equal(channel);\n}\n\nconst authRequests = authServer.getAuthRequests();\nexpect(authRequests).to.have.lengthOf(channels.length);\n\n// Each channel should have its own auth request\nchannels.forEach(channelName =&gt; {\n    const request = authRequests.find(r =&gt; r.channel_name === channelName);\n    expect(request).to.exist;\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;8be463ff-cae5-4c2f-82f9-7ed270740b94&quot;,&quot;parentUUID&quot;:&quot;9b0daae8-3086-4ed8-a55f-b33bda839963&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;e85b64e6-413e-4e70-9c66-3e6821dd0059&quot;,&quot;d5eae23b-2e28-4561-84ae-ba133a9ef391&quot;,&quot;8be463ff-cae5-4c2f-82f9-7ed270740b94&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:5032,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:15000},{&quot;uuid&quot;:&quot;6cc15ea9-2d54-4e60-8bf2-27ef503bbeb8&quot;,&quot;title&quot;:&quot;Presence Channel Authentication&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/auth.test.js&quot;,&quot;file&quot;:&quot;/tests/auth.test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should authenticate with user data&quot;,&quot;fullTitle&quot;:&quot;Authentication Tests Presence Channel Authentication should authenticate with user data&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = &#x27;presence-auth-test&#x27;;\n\nconst { channel } = await client.subscribe(channelName);\n\nexpect(channel).to.exist;\n\n// Check presence member data\nconst members = client.getPresenceMembers(channelName);\nexpect(members).to.exist;\nexpect(members.me).to.exist;\nexpect(members.me.id).to.be.a(&#x27;string&#x27;);\nexpect(members.me.info).to.exist;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1a638595-2aeb-4bb0-987d-cf55354f397b&quot;,&quot;parentUUID&quot;:&quot;6cc15ea9-2d54-4e60-8bf2-27ef503bbeb8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should include user data in presence subscription&quot;,&quot;fullTitle&quot;:&quot;Authentication Tests Presence Channel Authentication should include user data in presence subscription&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4,&quot;state&quot;:&quot;failed&quot;,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = &#x27;presence-data-test&#x27;;\n\nconst { channel } = await client.subscribe(channelName);\nexpect(channel).to.exist;\n\n// Presence channel subscription should include user data\nconst members = client.getPresenceMembers(channelName);\nexpect(members.me.info).to.have.property(&#x27;name&#x27;);\nexpect(members.me.info).to.have.property(&#x27;email&#x27;);&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;AssertionError: expected { user_id: &#x27;6046824231&#x27;, …(1) } to have property &#x27;name&#x27;&quot;,&quot;estack&quot;:&quot;AssertionError: expected { user_id: &#x27;6046824231&#x27;, …(1) } to have property &#x27;name&#x27;\n    at Context.&lt;anonymous&gt; (tests/auth.test.js:122:45)\n    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)&quot;},&quot;uuid&quot;:&quot;9d77883f-35dd-4e7f-a5e7-bd5a587dfc53&quot;,&quot;parentUUID&quot;:&quot;6cc15ea9-2d54-4e60-8bf2-27ef503bbeb8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should reject presence subscription without user data&quot;,&quot;fullTitle&quot;:&quot;Authentication Tests Presence Channel Authentication should reject presence subscription without user data&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:6,&quot;state&quot;:&quot;failed&quot;,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Create auth server that doesn&#x27;t return channel_data for presence channels\nconst badAuthServer = new AuthServer({ port: 3007 });\nbadAuthServer.app.post(&#x27;/pusher/auth&#x27;, (req, res) =&gt; {\n    const { socket_id, channel_name } = req.body;\n    const stringToSign = `${socket_id}:${channel_name}`;\n    const auth = crypto\n        .createHmac(&#x27;sha256&#x27;, badAuthServer.appSecret)\n        .update(stringToSign)\n        .digest(&#x27;hex&#x27;);\n    \n    // Return auth without channel_data (invalid for presence channels)\n    res.json({ auth: `${badAuthServer.appKey}:${auth}` });\n});\nawait badAuthServer.start();\n\nconst clientWithBadAuth = new TestClient({\n    authEndpoint: &#x27;http://localhost:3007/pusher/auth&#x27;\n});\n\ntry {\n    await clientWithBadAuth.connect();\n    await clientWithBadAuth.subscribe(&#x27;presence-no-data&#x27;);\n    expect.fail(&#x27;Should have thrown an error&#x27;);\n} catch (error) {\n    expect(error).to.be.an(&#x27;error&#x27;);\n} finally {\n    await clientWithBadAuth.disconnect();\n    await badAuthServer.stop();\n}&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;AssertionError: expected AssertionError{ …(6) } to be an error&quot;,&quot;estack&quot;:&quot;AssertionError: expected AssertionError{ …(6) } to be an error\n    at Context.&lt;anonymous&gt; (tests/auth.test.js:151:37)\n    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)&quot;},&quot;uuid&quot;:&quot;42f3cdd3-6e26-4afa-895e-2b908fdfff13&quot;,&quot;parentUUID&quot;:&quot;6cc15ea9-2d54-4e60-8bf2-27ef503bbeb8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;1a638595-2aeb-4bb0-987d-cf55354f397b&quot;],&quot;failures&quot;:[&quot;9d77883f-35dd-4e7f-a5e7-bd5a587dfc53&quot;,&quot;42f3cdd3-6e26-4afa-895e-2b908fdfff13&quot;],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:14,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:15000},{&quot;uuid&quot;:&quot;d1a6057e-003e-411a-a7db-42332a485651&quot;,&quot;title&quot;:&quot;User Authentication&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/auth.test.js&quot;,&quot;file&quot;:&quot;/tests/auth.test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should authenticate user with watchlist&quot;,&quot;fullTitle&quot;:&quot;Authentication Tests User Authentication should authenticate user with watchlist&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// This tests the user authentication feature if enabled\n// User auth allows tracking user activity across channels\n\nconst userAuthClient = new TestClient({\n    auth: {\n        params: {},\n        headers: {},\n        endpoint: `http://localhost:${authServer.port}/pusher/user-auth`\n    }\n});\n\nawait userAuthClient.connect();\n\n// If user auth is supported, the client should have user data\n// This feature might not be enabled in all configurations\n\nawait userAuthClient.disconnect();&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2b3bf17e-833b-414a-8137-9ecfc25b6f16&quot;,&quot;parentUUID&quot;:&quot;d1a6057e-003e-411a-a7db-42332a485651&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;2b3bf17e-833b-414a-8137-9ecfc25b6f16&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:2,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:15000},{&quot;uuid&quot;:&quot;94b99951-cab6-405c-9311-d107e4d46568&quot;,&quot;title&quot;:&quot;Authentication Timeout&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/auth.test.js&quot;,&quot;file&quot;:&quot;/tests/auth.test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should timeout authentication if no response&quot;,&quot;fullTitle&quot;:&quot;Authentication Tests Authentication Timeout should timeout authentication if no response&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:7,&quot;state&quot;:&quot;failed&quot;,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Create an auth server that never responds\nconst slowAuthServer = new AuthServer({ port: 3008 });\nslowAuthServer.app.post(&#x27;/pusher/auth&#x27;, async (req, res) =&gt; {\n    // Never respond to simulate timeout\n    await new Promise(() =&gt; {}); // Hang forever\n});\nawait slowAuthServer.start();\n\nconst clientWithSlowAuth = new TestClient({\n    authEndpoint: &#x27;http://localhost:3008/pusher/auth&#x27;\n});\n\ntry {\n    await clientWithSlowAuth.connect();\n    await clientWithSlowAuth.subscribe(&#x27;private-timeout-test&#x27;);\n    expect.fail(&#x27;Should have thrown a timeout error&#x27;);\n} catch (error) {\n    expect(error).to.be.an(&#x27;error&#x27;);\n    expect(error.message).to.include(&#x27;timeout&#x27;);\n} finally {\n    await clientWithSlowAuth.disconnect();\n    await slowAuthServer.stop();\n}&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;AssertionError: expected AssertionError{ …(6) } to be an error&quot;,&quot;estack&quot;:&quot;AssertionError: expected AssertionError{ …(6) } to be an error\n    at Context.&lt;anonymous&gt; (tests/auth.test.js:200:37)\n    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)&quot;},&quot;uuid&quot;:&quot;e38358e8-c271-4591-9d2d-b593083f448e&quot;,&quot;parentUUID&quot;:&quot;94b99951-cab6-405c-9311-d107e4d46568&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[],&quot;failures&quot;:[&quot;e38358e8-c271-4591-9d2d-b593083f448e&quot;],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:7,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:15000},{&quot;uuid&quot;:&quot;c2d281a2-1f70-4a22-9211-f04d663b2953&quot;,&quot;title&quot;:&quot;Authentication Security&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/auth.test.js&quot;,&quot;file&quot;:&quot;/tests/auth.test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should not allow reusing auth signatures across different sockets&quot;,&quot;fullTitle&quot;:&quot;Authentication Tests Authentication Security should not allow reusing auth signatures across different sockets&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:15,&quot;state&quot;:&quot;failed&quot;,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Get auth signature for first client\nconst channel1 = &#x27;private-security-test&#x27;;\nawait client.subscribe(channel1);\n\n// Try to use the same auth with a different client\n// This should fail because socket_id is different\nconst client2 = new TestClient();\nawait client2.connect();\n\n// The auth server will generate a new signature for the new socket_id\n// so this should succeed but with a different signature\nawait client2.subscribe(channel1);\n\nconst authRequests = authServer.getAuthRequests();\nexpect(authRequests).to.have.lengthOf(2);\nexpect(authRequests[0].socket_id).to.not.equal(authRequests[1].socket_id);\n\nawait client2.disconnect();&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;AssertionError: expected [ { …(3) } ] to have a length of 2 but got 1&quot;,&quot;estack&quot;:&quot;AssertionError: expected [ { …(3) } ] to have a length of 2 but got 1\n    at Context.&lt;anonymous&gt; (tests/auth.test.js:225:42)\n    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)&quot;,&quot;diff&quot;:&quot;- 1\n+ 2\n&quot;},&quot;uuid&quot;:&quot;bef75619-320b-41a5-b5f2-0db97c472501&quot;,&quot;parentUUID&quot;:&quot;c2d281a2-1f70-4a22-9211-f04d663b2953&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should not allow auth for channels not requested&quot;,&quot;fullTitle&quot;:&quot;Authentication Tests Authentication Security should not allow auth for channels not requested&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:6,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Try to subscribe to a channel different from what was authenticated\n// This test verifies the server validates the channel in the auth signature\n\nconst validChannel = &#x27;private-valid-channel&#x27;;\nconst invalidChannel = &#x27;private-different-channel&#x27;;\n\n// The auth server will authenticate for any channel requested\n// but the signature will only be valid for that specific channel\nawait client.subscribe(validChannel);\n\n// Trying to subscribe to a different channel should require new auth\nawait client.subscribe(invalidChannel);\n\nconst authRequests = authServer.getAuthRequests();\nexpect(authRequests).to.have.lengthOf(2);\nexpect(authRequests[0].channel_name).to.equal(validChannel);\nexpect(authRequests[1].channel_name).to.equal(invalidChannel);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;72ac04c2-b896-4c79-ac6e-ac250ca24474&quot;,&quot;parentUUID&quot;:&quot;c2d281a2-1f70-4a22-9211-f04d663b2953&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;72ac04c2-b896-4c79-ac6e-ac250ca24474&quot;],&quot;failures&quot;:[&quot;bef75619-320b-41a5-b5f2-0db97c472501&quot;],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:21,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:15000},{&quot;uuid&quot;:&quot;28f71fbc-e48a-4676-abe9-2049a4f3072a&quot;,&quot;title&quot;:&quot;Authentication Error Handling&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/auth.test.js&quot;,&quot;file&quot;:&quot;/tests/auth.test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should handle auth endpoint returning 403&quot;,&quot;fullTitle&quot;:&quot;Authentication Tests Authentication Error Handling should handle auth endpoint returning 403&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5,&quot;state&quot;:&quot;failed&quot;,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;code&quot;:&quot;const forbiddenAuthServer = new AuthServer({ port: 3009 });\nforbiddenAuthServer.app.post(&#x27;/pusher/auth&#x27;, (req, res) =&gt; {\n    res.status(403).json({ error: &#x27;Forbidden&#x27; });\n});\nawait forbiddenAuthServer.start();\n\nconst clientWithForbidden = new TestClient({\n    authEndpoint: &#x27;http://localhost:3009/pusher/auth&#x27;\n});\n\ntry {\n    await clientWithForbidden.connect();\n    await clientWithForbidden.subscribe(&#x27;private-forbidden&#x27;);\n    expect.fail(&#x27;Should have thrown an error&#x27;);\n} catch (error) {\n    expect(error).to.be.an(&#x27;error&#x27;);\n} finally {\n    await clientWithForbidden.disconnect();\n    await forbiddenAuthServer.stop();\n}&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;AssertionError: expected AssertionError{ …(6) } to be an error&quot;,&quot;estack&quot;:&quot;AssertionError: expected AssertionError{ …(6) } to be an error\n    at Context.&lt;anonymous&gt; (tests/auth.test.js:269:37)\n    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)&quot;},&quot;uuid&quot;:&quot;fce35108-8022-44b8-aff6-e0fbc1e86fce&quot;,&quot;parentUUID&quot;:&quot;28f71fbc-e48a-4676-abe9-2049a4f3072a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should handle auth endpoint returning invalid JSON&quot;,&quot;fullTitle&quot;:&quot;Authentication Tests Authentication Error Handling should handle auth endpoint returning invalid JSON&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4,&quot;state&quot;:&quot;failed&quot;,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;code&quot;:&quot;const badJsonAuthServer = new AuthServer({ port: 3010 });\nbadJsonAuthServer.app.post(&#x27;/pusher/auth&#x27;, (req, res) =&gt; {\n    res.send(&#x27;not valid json&#x27;);\n});\nawait badJsonAuthServer.start();\n\nconst clientWithBadJson = new TestClient({\n    authEndpoint: &#x27;http://localhost:3010/pusher/auth&#x27;\n});\n\ntry {\n    await clientWithBadJson.connect();\n    await clientWithBadJson.subscribe(&#x27;private-bad-json&#x27;);\n    expect.fail(&#x27;Should have thrown an error&#x27;);\n} catch (error) {\n    expect(error).to.be.an(&#x27;error&#x27;);\n} finally {\n    await clientWithBadJson.disconnect();\n    await badJsonAuthServer.stop();\n}&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;AssertionError: expected AssertionError{ …(6) } to be an error&quot;,&quot;estack&quot;:&quot;AssertionError: expected AssertionError{ …(6) } to be an error\n    at Context.&lt;anonymous&gt; (tests/auth.test.js:292:37)\n    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)&quot;},&quot;uuid&quot;:&quot;aaf351e3-5c9a-469f-bbca-d98cc6d9889a&quot;,&quot;parentUUID&quot;:&quot;28f71fbc-e48a-4676-abe9-2049a4f3072a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should handle auth endpoint being unreachable&quot;,&quot;fullTitle&quot;:&quot;Authentication Tests Authentication Error Handling should handle auth endpoint being unreachable&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const clientWithNoAuth = new TestClient({\n    authEndpoint: &#x27;http://localhost:9999/pusher/auth&#x27; // Non-existent endpoint\n});\n\ntry {\n    await clientWithNoAuth.connect();\n    await clientWithNoAuth.subscribe(&#x27;private-unreachable&#x27;);\n    expect.fail(&#x27;Should have thrown an error&#x27;);\n} catch (error) {\n    expect(error).to.be.an(&#x27;error&#x27;);\n} finally {\n    await clientWithNoAuth.disconnect();\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7d981a6d-e60c-4b62-8921-f7f898938e0a&quot;,&quot;parentUUID&quot;:&quot;28f71fbc-e48a-4676-abe9-2049a4f3072a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;7d981a6d-e60c-4b62-8921-f7f898938e0a&quot;],&quot;failures&quot;:[&quot;fce35108-8022-44b8-aff6-e0fbc1e86fce&quot;,&quot;aaf351e3-5c9a-469f-bbca-d98cc6d9889a&quot;],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:11,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:15000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:15000},{&quot;uuid&quot;:&quot;06faca08-701a-4b22-9db3-ae3a31cc6bdc&quot;,&quot;title&quot;:&quot;Channel Subscription Tests&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/channels.test.js&quot;,&quot;file&quot;:&quot;/tests/channels.test.js&quot;,&quot;beforeHooks&quot;:[{&quot;title&quot;:&quot;\&quot;before each\&quot; hook in \&quot;Channel Subscription Tests\&quot;&quot;,&quot;fullTitle&quot;:&quot;Channel Subscription Tests \&quot;before each\&quot; hook in \&quot;Channel Subscription Tests\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = new TestClient();\nawait client.connect();&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;38e6c5a8-b198-4791-99d9-5db7876d66fa&quot;,&quot;parentUUID&quot;:&quot;06faca08-701a-4b22-9db3-ae3a31cc6bdc&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;afterHooks&quot;:[{&quot;title&quot;:&quot;\&quot;after each\&quot; hook in \&quot;Channel Subscription Tests\&quot;&quot;,&quot;fullTitle&quot;:&quot;Channel Subscription Tests \&quot;after each\&quot; hook in \&quot;Channel Subscription Tests\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:0,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;if (client &amp;&amp; client.isConnected()) {\n    await client.disconnect();\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;00bee98c-f952-4e3e-8c5e-989ebf7e8ea4&quot;,&quot;parentUUID&quot;:&quot;06faca08-701a-4b22-9db3-ae3a31cc6bdc&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;cd8232f6-4c84-4b9f-addc-28122e63128f&quot;,&quot;title&quot;:&quot;Public Channels&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/channels.test.js&quot;,&quot;file&quot;:&quot;/tests/channels.test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should subscribe to a public channel&quot;,&quot;fullTitle&quot;:&quot;Channel Subscription Tests Public Channels should subscribe to a public channel&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = TestUtils.generateChannelName(&#x27;public&#x27;);\n\nconst { channel, data } = await client.subscribe(channelName);\n\nexpect(channel).to.exist;\nexpect(client.getChannel(channelName)).to.equal(channel);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b922b4d6-88f4-4db8-8a7b-ce08d006cfc0&quot;,&quot;parentUUID&quot;:&quot;cd8232f6-4c84-4b9f-addc-28122e63128f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should unsubscribe from a public channel&quot;,&quot;fullTitle&quot;:&quot;Channel Subscription Tests Public Channels should unsubscribe from a public channel&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = TestUtils.generateChannelName(&#x27;public&#x27;);\n\nawait client.subscribe(channelName);\nexpect(client.getChannel(channelName)).to.exist;\n\nawait client.unsubscribe(channelName);\nexpect(client.getChannel(channelName)).to.be.undefined;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;70323853-ad50-4bff-bbd7-7181947f2fb7&quot;,&quot;parentUUID&quot;:&quot;cd8232f6-4c84-4b9f-addc-28122e63128f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should subscribe to multiple public channels&quot;,&quot;fullTitle&quot;:&quot;Channel Subscription Tests Public Channels should subscribe to multiple public channels&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channels = [];\nconst channelCount = 5;\n\nfor (let i = 0; i &lt; channelCount; i++) {\n    const channelName = TestUtils.generateChannelName(`public-${i}`);\n    await client.subscribe(channelName);\n    channels.push(channelName);\n}\n\n// Verify all channels are subscribed\nchannels.forEach(channelName =&gt; {\n    expect(client.getChannel(channelName)).to.exist;\n});&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3eb50c35-994a-4a62-93a3-c33554b5e48a&quot;,&quot;parentUUID&quot;:&quot;cd8232f6-4c84-4b9f-addc-28122e63128f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should handle duplicate subscription attempts&quot;,&quot;fullTitle&quot;:&quot;Channel Subscription Tests Public Channels should handle duplicate subscription attempts&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5005,&quot;state&quot;:&quot;failed&quot;,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = TestUtils.generateChannelName(&#x27;public&#x27;);\n\n// First subscription\nconst { channel: channel1 } = await client.subscribe(channelName);\n\n// Try to subscribe again\nconst { channel: channel2 } = await client.subscribe(channelName);\n\n// Should return the same channel object\nexpect(channel1).to.equal(channel2);&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;Error: Subscription timeout for channel: public-channel-26qkyn&quot;,&quot;estack&quot;:&quot;Error: Subscription timeout for channel: public-channel-26qkyn\n    at Timeout._onTimeout (lib/TestClient.js:65:24)\n    at listOnTimeout (node:internal/timers:588:17)\n    at process.processTimers (node:internal/timers:523:7)&quot;},&quot;uuid&quot;:&quot;5b6a6893-5fce-40a8-82dd-25b694264d40&quot;,&quot;parentUUID&quot;:&quot;cd8232f6-4c84-4b9f-addc-28122e63128f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;b922b4d6-88f4-4db8-8a7b-ce08d006cfc0&quot;,&quot;70323853-ad50-4bff-bbd7-7181947f2fb7&quot;,&quot;3eb50c35-994a-4a62-93a3-c33554b5e48a&quot;],&quot;failures&quot;:[&quot;5b6a6893-5fce-40a8-82dd-25b694264d40&quot;],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:5018,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:15000},{&quot;uuid&quot;:&quot;e15b0996-97cc-4a4d-8215-fad4d6382b5a&quot;,&quot;title&quot;:&quot;Private Channels&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/channels.test.js&quot;,&quot;file&quot;:&quot;/tests/channels.test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should subscribe to a private channel with authentication&quot;,&quot;fullTitle&quot;:&quot;Channel Subscription Tests Private Channels should subscribe to a private channel with authentication&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;failed&quot;,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = &#x27;private-test-channel&#x27;;\n\nconst { channel } = await client.subscribe(channelName);\n\nexpect(channel).to.exist;\nexpect(client.getChannel(channelName)).to.equal(channel);\n\n// Verify auth request was made\nconst authRequests = authServer.getAuthRequests();\nconst authRequest = authRequests.find(r =&gt; r.channel_name === channelName);\nexpect(authRequest).to.exist;\nexpect(authRequest.socket_id).to.equal(client.getSocketId());&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;ReferenceError: authServer is not defined&quot;,&quot;estack&quot;:&quot;ReferenceError: authServer is not defined\n    at Context.&lt;anonymous&gt; (tests/channels.test.js:81:34)\n    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)&quot;},&quot;uuid&quot;:&quot;1ff85637-e419-4219-a456-afb980f8a58c&quot;,&quot;parentUUID&quot;:&quot;e15b0996-97cc-4a4d-8215-fad4d6382b5a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail to subscribe without proper authentication&quot;,&quot;fullTitle&quot;:&quot;Channel Subscription Tests Private Channels should fail to subscribe without proper authentication&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5,&quot;state&quot;:&quot;failed&quot;,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Use a client without auth endpoint configured\nconst unauthClient = new TestClient({ authEndpoint: null });\nawait unauthClient.connect();\n\ntry {\n    await unauthClient.subscribe(&#x27;private-test-channel&#x27;);\n    expect.fail(&#x27;Should have thrown an error&#x27;);\n} catch (error) {\n    expect(error).to.be.an(&#x27;error&#x27;);\n} finally {\n    await unauthClient.disconnect();\n}&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;AssertionError: expected AssertionError{ …(6) } to be an error&quot;,&quot;estack&quot;:&quot;AssertionError: expected AssertionError{ …(6) } to be an error\n    at Context.&lt;anonymous&gt; (tests/channels.test.js:96:37)\n    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)&quot;},&quot;uuid&quot;:&quot;870bdaf6-acd7-4d87-be43-6452ccd2d0bf&quot;,&quot;parentUUID&quot;:&quot;e15b0996-97cc-4a4d-8215-fad4d6382b5a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should not allow client events on public channels&quot;,&quot;fullTitle&quot;:&quot;Channel Subscription Tests Private Channels should not allow client events on public channels&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = &#x27;public-test-channel&#x27;;\nawait client.subscribe(channelName);\n\ntry {\n    await client.trigger(channelName, &#x27;client-test-event&#x27;, { data: &#x27;test&#x27; });\n    expect.fail(&#x27;Should have thrown an error&#x27;);\n} catch (error) {\n    expect(error.message).to.include(&#x27;Client events only supported on private/presence channels&#x27;);\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;5a991231-6dc5-4931-8dba-c064a84c9666&quot;,&quot;parentUUID&quot;:&quot;e15b0996-97cc-4a4d-8215-fad4d6382b5a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should allow client events on private channels&quot;,&quot;fullTitle&quot;:&quot;Channel Subscription Tests Private Channels should allow client events on private channels&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = &#x27;private-test-channel&#x27;;\nawait client.subscribe(channelName);\n\n// Should not throw\nawait client.trigger(channelName, &#x27;client-test-event&#x27;, { data: &#x27;test&#x27; });&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;69511e13-08e8-4304-882b-abbfa56d7e4d&quot;,&quot;parentUUID&quot;:&quot;e15b0996-97cc-4a4d-8215-fad4d6382b5a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;5a991231-6dc5-4931-8dba-c064a84c9666&quot;,&quot;69511e13-08e8-4304-882b-abbfa56d7e4d&quot;],&quot;failures&quot;:[&quot;1ff85637-e419-4219-a456-afb980f8a58c&quot;,&quot;870bdaf6-acd7-4d87-be43-6452ccd2d0bf&quot;],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:14,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:15000},{&quot;uuid&quot;:&quot;cf54d3c2-8bc8-4915-864d-d6d82f4e5141&quot;,&quot;title&quot;:&quot;Presence Channels&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/channels.test.js&quot;,&quot;file&quot;:&quot;/tests/channels.test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[{&quot;title&quot;:&quot;\&quot;after each\&quot; hook in \&quot;Presence Channels\&quot;&quot;,&quot;fullTitle&quot;:&quot;Channel Subscription Tests Presence Channels \&quot;after each\&quot; hook in \&quot;Presence Channels\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;if (client2 &amp;&amp; client2.isConnected()) {\n    await client2.disconnect();\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;fed8cc41-35d3-4519-8e18-db8246f1b301&quot;,&quot;parentUUID&quot;:&quot;cf54d3c2-8bc8-4915-864d-d6d82f4e5141&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;tests&quot;:[{&quot;title&quot;:&quot;should subscribe to a presence channel with member data&quot;,&quot;fullTitle&quot;:&quot;Channel Subscription Tests Presence Channels should subscribe to a presence channel with member data&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = &#x27;presence-test-channel&#x27;;\n\nconst { channel } = await client.subscribe(channelName);\n\nexpect(channel).to.exist;\n\n// Check member data\nconst members = client.getPresenceMembers(channelName);\nexpect(members).to.exist;\nexpect(members.count).to.equal(1);\nexpect(members.me).to.exist;\nexpect(members.me.id).to.be.a(&#x27;string&#x27;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4e62bb0d-044c-4530-b1b2-9a5ea2fdadbe&quot;,&quot;parentUUID&quot;:&quot;cf54d3c2-8bc8-4915-864d-d6d82f4e5141&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should track member join events&quot;,&quot;fullTitle&quot;:&quot;Channel Subscription Tests Presence Channels should track member join events&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:45,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = &#x27;presence-test-channel&#x27;;\n\n// First client subscribes\nawait client.subscribe(channelName);\n\n// Set up event listener for member_added\nconst memberAddedPromise = client.waitForEvent(channelName, &#x27;pusher:member_added&#x27;, 5000);\n\n// Second client subscribes\nclient2 = new TestClient();\nawait client2.connect();\nawait client2.subscribe(channelName);\n\n// Wait for member_added event\nconst memberData = await memberAddedPromise;\nexpect(memberData).to.exist;\nexpect(memberData.id).to.be.a(&#x27;string&#x27;);\n\n// Check updated member count\nconst members = client.getPresenceMembers(channelName);\nexpect(members.count).to.equal(2);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7e74ea1e-4974-43a6-a3b9-614538530ce6&quot;,&quot;parentUUID&quot;:&quot;cf54d3c2-8bc8-4915-864d-d6d82f4e5141&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should track member leave events&quot;,&quot;fullTitle&quot;:&quot;Channel Subscription Tests Presence Channels should track member leave events&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1013,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = &#x27;presence-test-channel&#x27;;\n\n// Both clients subscribe\nawait client.subscribe(channelName);\n\nclient2 = new TestClient();\nawait client2.connect();\nawait client2.subscribe(channelName);\n\n// Wait for subscription to stabilize\nawait TestUtils.wait(1000);\n\n// Set up event listener for member_removed\nconst memberRemovedPromise = client.waitForEvent(channelName, &#x27;pusher:member_removed&#x27;, 5000);\n\n// Second client unsubscribes\nawait client2.unsubscribe(channelName);\n\n// Wait for member_removed event\nconst memberData = await memberRemovedPromise;\nexpect(memberData).to.exist;\n\n// Check updated member count\nconst members = client.getPresenceMembers(channelName);\nexpect(members.count).to.equal(1);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;07fbe6fb-5a36-485e-8d08-55a69f021da7&quot;,&quot;parentUUID&quot;:&quot;cf54d3c2-8bc8-4915-864d-d6d82f4e5141&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should provide initial members list on subscription&quot;,&quot;fullTitle&quot;:&quot;Channel Subscription Tests Presence Channels should provide initial members list on subscription&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = &#x27;presence-test-channel&#x27;;\n\n// First client subscribes\nclient2 = new TestClient();\nawait client2.connect();\nawait client2.subscribe(channelName);\n\n// Second client subscribes and should receive initial members\nconst { channel, data } = await client.subscribe(channelName);\n\n// Check members list includes both clients\nconst members = client.getPresenceMembers(channelName);\nexpect(members).to.exist;\nexpect(members.count).to.equal(2);\nexpect(Object.keys(members.members).length).to.equal(2);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;03572133-23c9-4385-8519-528873aad45e&quot;,&quot;parentUUID&quot;:&quot;cf54d3c2-8bc8-4915-864d-d6d82f4e5141&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;4e62bb0d-044c-4530-b1b2-9a5ea2fdadbe&quot;,&quot;7e74ea1e-4974-43a6-a3b9-614538530ce6&quot;,&quot;07fbe6fb-5a36-485e-8d08-55a69f021da7&quot;,&quot;03572133-23c9-4385-8519-528873aad45e&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:1071,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:15000},{&quot;uuid&quot;:&quot;1780c8e7-39fc-4eac-b657-eb8d3992bdb1&quot;,&quot;title&quot;:&quot;Channel Name Validation&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/channels.test.js&quot;,&quot;file&quot;:&quot;/tests/channels.test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should reject invalid channel names&quot;,&quot;fullTitle&quot;:&quot;Channel Subscription Tests Channel Name Validation should reject invalid channel names&quot;,&quot;timedOut&quot;:true,&quot;duration&quot;:15002,&quot;state&quot;:&quot;failed&quot;,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;code&quot;:&quot;const invalidNames = [\n    &#x27;&#x27;, // empty\n    &#x27;a&#x27;.repeat(201), // too long (assuming 200 char limit)\n    &#x27;channel with spaces&#x27;, // spaces not allowed\n    &#x27;channel#with#hashes&#x27;, // special characters\n];\n\nfor (const invalidName of invalidNames) {\n    try {\n        await client.subscribe(invalidName);\n        expect.fail(`Should have rejected channel name: ${invalidName}`);\n    } catch (error) {\n        expect(error).to.be.an(&#x27;error&#x27;);\n    }\n}&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;Error: Timeout of 15000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves. (/var/www/sockudo/test/integration/tests/channels.test.js)&quot;,&quot;estack&quot;:&quot;Error: Timeout of 15000ms exceeded. For async tests and hooks, ensure \&quot;done()\&quot; is called; if returning a Promise, ensure it resolves. (/var/www/sockudo/test/integration/tests/channels.test.js)\n    at listOnTimeout (node:internal/timers:588:17)\n    at process.processTimers (node:internal/timers:523:7)&quot;},&quot;uuid&quot;:&quot;ec6df2f9-8bb1-4daa-8038-beee29c13a12&quot;,&quot;parentUUID&quot;:&quot;1780c8e7-39fc-4eac-b657-eb8d3992bdb1&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should accept valid channel names&quot;,&quot;fullTitle&quot;:&quot;Channel Subscription Tests Channel Name Validation should accept valid channel names&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:20,&quot;state&quot;:&quot;failed&quot;,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;code&quot;:&quot;const validNames = [\n    &#x27;simple-channel&#x27;,\n    &#x27;channel_with_underscores&#x27;,\n    &#x27;channel.with.dots&#x27;,\n    &#x27;channel:with:colons&#x27;,\n    &#x27;private-valid-channel&#x27;,\n    &#x27;presence-valid-channel&#x27;,\n    &#x27;private-encrypted-valid-channel&#x27;\n];\n\nfor (const validName of validNames) {\n    await client.subscribe(validName);\n    expect(client.getChannel(validName)).to.exist;\n    await client.unsubscribe(validName);\n}&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;Error: Subscription error for private-encrypted-valid-channel: No shared_secret key in auth payload for encrypted channel: private-encrypted-valid-channel&quot;,&quot;estack&quot;:&quot;Error: Subscription error for private-encrypted-valid-channel: No shared_secret key in auth payload for encrypted channel: private-encrypted-valid-channel\n    at /var/www/sockudo/test/integration/lib/TestClient.js:83:24\n    at encrypted_channel_EncryptedChannel.emit (node_modules/pusher-js/dist/node/pusher.js:7669:33)\n    at /var/www/sockudo/test/integration/node_modules/pusher-js/dist/node/pusher.js:8423:22\n    at /var/www/sockudo/test/integration/node_modules/pusher-js/dist/node/pusher.js:8639:17\n    at xhr.onreadystatechange (node_modules/pusher-js/dist/node/pusher.js:9951:21)\n    at module.exports.exports.XMLHttpRequest.dispatchEvent (node_modules/pusher-js/dist/node/pusher.js:2720:25)\n    at setState (node_modules/pusher-js/dist/node/pusher.js:2739:14)\n    at IncomingMessage.&lt;anonymous&gt; (node_modules/pusher-js/dist/node/pusher.js:2576:13)\n    at IncomingMessage.emit (node:events:530:35)\n    at endReadableNT (node:internal/streams/readable:1698:12)\n    at process.processTicksAndRejections (node:internal/process/task_queues:90:21)&quot;},&quot;uuid&quot;:&quot;70f2c338-290d-4974-b2ff-1ad68376c61f&quot;,&quot;parentUUID&quot;:&quot;1780c8e7-39fc-4eac-b657-eb8d3992bdb1&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[],&quot;failures&quot;:[&quot;ec6df2f9-8bb1-4daa-8038-beee29c13a12&quot;,&quot;70f2c338-290d-4974-b2ff-1ad68376c61f&quot;],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:15022,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:15000},{&quot;uuid&quot;:&quot;7336d8d8-bf58-485c-b2e7-832c408ee8ab&quot;,&quot;title&quot;:&quot;Channel Limits&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/channels.test.js&quot;,&quot;file&quot;:&quot;/tests/channels.test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should handle subscription to many channels&quot;,&quot;fullTitle&quot;:&quot;Channel Subscription Tests Channel Limits should handle subscription to many channels&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:108,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelCount = 50;\nconst channels = [];\n\nfor (let i = 0; i &lt; channelCount; i++) {\n    const channelName = TestUtils.generateChannelName(`stress-${i}`);\n    await client.subscribe(channelName);\n    channels.push(channelName);\n}\n\n// Verify all channels are subscribed\nexpect(client.channels.size).to.equal(channelCount);\n\n// Cleanup\nfor (const channelName of channels) {\n    await client.unsubscribe(channelName);\n}\n\nexpect(client.channels.size).to.equal(0);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ab0843e3-543e-438c-859d-048806898a8f&quot;,&quot;parentUUID&quot;:&quot;7336d8d8-bf58-485c-b2e7-832c408ee8ab&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should enforce max channels per connection limit if configured&quot;,&quot;fullTitle&quot;:&quot;Channel Subscription Tests Channel Limits should enforce max channels per connection limit if configured&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:247,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// This test assumes there might be a max channels limit\n// The actual limit should be configured in the test environment\nconst maxChannels = 100; // Adjust based on server configuration\n\ntry {\n    for (let i = 0; i &lt; maxChannels + 10; i++) {\n        const channelName = TestUtils.generateChannelName(`limit-test-${i}`);\n        await client.subscribe(channelName);\n    }\n    \n    // If we get here, either no limit or limit is higher\n    console.log(`Successfully subscribed to ${client.channels.size} channels`);\n    \n} catch (error) {\n    // Expected if there&#x27;s a channel limit\n    expect(client.channels.size).to.be.at.most(maxChannels);\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;903893d9-e24a-4e45-a1b0-7839c10d1c52&quot;,&quot;parentUUID&quot;:&quot;7336d8d8-bf58-485c-b2e7-832c408ee8ab&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;ab0843e3-543e-438c-859d-048806898a8f&quot;,&quot;903893d9-e24a-4e45-a1b0-7839c10d1c52&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:355,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:15000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:15000},{&quot;uuid&quot;:&quot;1cc17c5f-0375-4ab7-bb2b-1471117dced6&quot;,&quot;title&quot;:&quot;Connection Tests&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/connection.test.js&quot;,&quot;file&quot;:&quot;/tests/connection.test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[{&quot;title&quot;:&quot;\&quot;after each\&quot; hook in \&quot;Connection Tests\&quot;&quot;,&quot;fullTitle&quot;:&quot;Connection Tests \&quot;after each\&quot; hook in \&quot;Connection Tests\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:0,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;if (client &amp;&amp; client.isConnected()) {\n    await client.disconnect();\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;97f30472-4b18-433d-b3ef-0315327f5f9d&quot;,&quot;parentUUID&quot;:&quot;1cc17c5f-0375-4ab7-bb2b-1471117dced6&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;f407baf5-a23e-4b1b-8cd1-ff3a73cb3787&quot;,&quot;title&quot;:&quot;Basic Connection&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/connection.test.js&quot;,&quot;file&quot;:&quot;/tests/connection.test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should connect successfully with valid credentials&quot;,&quot;fullTitle&quot;:&quot;Connection Tests Basic Connection should connect successfully with valid credentials&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = new TestClient();\nconst socketId = await client.connect();\n\nexpect(socketId).to.be.a(&#x27;string&#x27;);\nexpect(socketId).to.match(/^\\d+\\.\\d+$/);\nexpect(client.isConnected()).to.be.true;\nexpect(client.getConnectionState()).to.equal(&#x27;connected&#x27;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;88fed748-4e6a-4c2e-bb72-6e0575fb4339&quot;,&quot;parentUUID&quot;:&quot;f407baf5-a23e-4b1b-8cd1-ff3a73cb3787&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should fail to connect with invalid app key&quot;,&quot;fullTitle&quot;:&quot;Connection Tests Basic Connection should fail to connect with invalid app key&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;failed&quot;,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = new TestClient({ key: &#x27;invalid-key&#x27; });\n\ntry {\n    await client.connect();\n    expect.fail(&#x27;Should have thrown an error&#x27;);\n} catch (error) {\n    expect(error).to.be.an(&#x27;error&#x27;);\n    expect(client.isConnected()).to.be.false;\n}&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;Error: Unhandled error. ({\n  type: &#x27;WebSocketError&#x27;,\n  error: { type: &#x27;PusherError&#x27;, data: { code: 1006, message: undefined } }\n})&quot;,&quot;estack&quot;:&quot;Error [ERR_UNHANDLED_ERROR]: Unhandled error. ({\n  type: &#x27;WebSocketError&#x27;,\n  error: { type: &#x27;PusherError&#x27;, data: { code: 1006, message: undefined } }\n})\n    at TestClient.emit (node:events:507:17)\n    at /var/www/sockudo/test/integration/lib/TestClient.js:44:22\n    at connection_manager_ConnectionManager.emit (node_modules/pusher-js/dist/node/pusher.js:7669:33)\n    at Object.backoff (node_modules/pusher-js/dist/node/pusher.js:8907:26)\n    at callback (node_modules/pusher-js/dist/node/pusher.js:8794:62)\n    at cb (node_modules/pusher-js/dist/node/pusher.js:9283:17)\n    at /var/www/sockudo/test/integration/node_modules/pusher-js/dist/node/pusher.js:9406:13\n    at /var/www/sockudo/test/integration/node_modules/pusher-js/dist/node/pusher.js:9195:17\n    at tryNextStrategy (node_modules/pusher-js/dist/node/pusher.js:9106:17)\n    at /var/www/sockudo/test/integration/node_modules/pusher-js/dist/node/pusher.js:9156:13\n    at handshake_Handshake.callback (node_modules/pusher-js/dist/node/pusher.js:10163:17)\n    at handshake_Handshake.finish (node_modules/pusher-js/dist/node/pusher.js:8234:14)\n    at onClosed (node_modules/pusher-js/dist/node/pusher.js:8224:18)\n    at transport_connection_TransportConnection.emit (node_modules/pusher-js/dist/node/pusher.js:7669:33)\n    at transport_connection_TransportConnection.changeState (node_modules/pusher-js/dist/node/pusher.js:7868:14)\n    at transport_connection_TransportConnection.onClose (node_modules/pusher-js/dist/node/pusher.js:7814:18)\n    at socket.onclose (node_modules/pusher-js/dist/node/pusher.js:7840:18)\n    at Client.dispatchEvent (node_modules/pusher-js/dist/node/pusher.js:1908:30)\n    at Client._finalizeClose (node_modules/pusher-js/dist/node/pusher.js:1133:10)\n    at Socket.&lt;anonymous&gt; (node_modules/pusher-js/dist/node/pusher.js:1068:48)\n    at Socket.emit (node:events:530:35)\n    at endReadableNT (node:internal/streams/readable:1698:12)\n    at process.processTicksAndRejections (node:internal/process/task_queues:90:21)&quot;},&quot;uuid&quot;:&quot;6b4db4f2-d1aa-446c-813c-1b93a860c065&quot;,&quot;parentUUID&quot;:&quot;f407baf5-a23e-4b1b-8cd1-ff3a73cb3787&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should disconnect gracefully&quot;,&quot;fullTitle&quot;:&quot;Connection Tests Basic Connection should disconnect gracefully&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = new TestClient();\nawait client.connect();\n\nexpect(client.isConnected()).to.be.true;\n\nawait client.disconnect();\n\nexpect(client.isConnected()).to.be.false;\nexpect(client.getConnectionState()).to.equal(&#x27;disconnected&#x27;);\nexpect(client.getSocketId()).to.be.null;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;e4065e58-489a-476b-a476-bf272a2d1ace&quot;,&quot;parentUUID&quot;:&quot;f407baf5-a23e-4b1b-8cd1-ff3a73cb3787&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should handle reconnection after disconnect&quot;,&quot;fullTitle&quot;:&quot;Connection Tests Basic Connection should handle reconnection after disconnect&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1007,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = new TestClient();\n\n// First connection\nconst firstSocketId = await client.connect();\nexpect(client.isConnected()).to.be.true;\n\n// Disconnect\nawait client.disconnect();\nexpect(client.isConnected()).to.be.false;\n\n// Wait a bit\nawait TestUtils.wait(1000);\n\n// Reconnect\nconst secondSocketId = await client.connect();\nexpect(client.isConnected()).to.be.true;\nexpect(secondSocketId).to.be.a(&#x27;string&#x27;);\n\n// Socket IDs should be different\nexpect(secondSocketId).to.not.equal(firstSocketId);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;166fa6c2-0a6a-4bc2-ac66-c62a2acf5d71&quot;,&quot;parentUUID&quot;:&quot;f407baf5-a23e-4b1b-8cd1-ff3a73cb3787&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;88fed748-4e6a-4c2e-bb72-6e0575fb4339&quot;,&quot;e4065e58-489a-476b-a476-bf272a2d1ace&quot;,&quot;166fa6c2-0a6a-4bc2-ac66-c62a2acf5d71&quot;],&quot;failures&quot;:[&quot;6b4db4f2-d1aa-446c-813c-1b93a860c065&quot;],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:1014,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:15000},{&quot;uuid&quot;:&quot;fbdcde04-3fb3-44cb-8f70-acf068c84367&quot;,&quot;title&quot;:&quot;Multiple Connections&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/connection.test.js&quot;,&quot;file&quot;:&quot;/tests/connection.test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[{&quot;title&quot;:&quot;\&quot;after each\&quot; hook in \&quot;Multiple Connections\&quot;&quot;,&quot;fullTitle&quot;:&quot;Connection Tests Multiple Connections \&quot;after each\&quot; hook in \&quot;Multiple Connections\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:0,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await TestUtils.cleanupClients(clients);\nclients = [];&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0bc2be88-37b0-4b0c-9aae-18d2c4a477ca&quot;,&quot;parentUUID&quot;:&quot;fbdcde04-3fb3-44cb-8f70-acf068c84367&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;tests&quot;:[{&quot;title&quot;:&quot;should handle multiple simultaneous connections&quot;,&quot;fullTitle&quot;:&quot;Connection Tests Multiple Connections should handle multiple simultaneous connections&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const connectionCount = 5;\nclients = await TestUtils.createClients(connectionCount);\n\n// Verify all clients are connected\nclients.forEach((client, index) =&gt; {\n    expect(client.isConnected()).to.be.true;\n    expect(client.getSocketId()).to.be.a(&#x27;string&#x27;);\n});\n\n// Verify each client has a unique socket ID\nconst socketIds = clients.map(c =&gt; c.getSocketId());\nconst uniqueSocketIds = [...new Set(socketIds)];\nexpect(uniqueSocketIds.length).to.equal(connectionCount);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b43fe1e2-00d2-4d72-9454-94fe6ac9411c&quot;,&quot;parentUUID&quot;:&quot;fbdcde04-3fb3-44cb-8f70-acf068c84367&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should handle rapid connect/disconnect cycles&quot;,&quot;fullTitle&quot;:&quot;Connection Tests Multiple Connections should handle rapid connect/disconnect cycles&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:7,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const cycles = 3;\n\nfor (let i = 0; i &lt; cycles; i++) {\n    const client = new TestClient();\n    await client.connect();\n    expect(client.isConnected()).to.be.true;\n    \n    await client.disconnect();\n    expect(client.isConnected()).to.be.false;\n    \n    clients.push(client);\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b8fab0bb-ea60-4f5d-acc4-0947b0f7a382&quot;,&quot;parentUUID&quot;:&quot;fbdcde04-3fb3-44cb-8f70-acf068c84367&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;b43fe1e2-00d2-4d72-9454-94fe6ac9411c&quot;,&quot;b8fab0bb-ea60-4f5d-acc4-0947b0f7a382&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:15,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:15000},{&quot;uuid&quot;:&quot;cb5165c7-904a-47c9-8614-b3dd74554bd3&quot;,&quot;title&quot;:&quot;Connection Events&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/connection.test.js&quot;,&quot;file&quot;:&quot;/tests/connection.test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should emit connection state changes&quot;,&quot;fullTitle&quot;:&quot;Connection Tests Connection Events should emit connection state changes&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:102,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = new TestClient();\nconst stateChanges = [];\n\n// Set up state listener before connecting\nclient.on(&#x27;state_change&#x27;, (states) =&gt; {\n    stateChanges.push(states.current);\n});\n\n// Connect and wait for completion\nawait client.connect();\n\n// Wait a bit for any additional state changes\nawait TestUtils.wait(100);\n\n// Should have seen some state changes\nexpect(stateChanges.length).to.be.greaterThan(0);\nexpect(stateChanges[stateChanges.length - 1]).to.equal(&#x27;connected&#x27;);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;95dcef7e-f608-4ef1-8ea4-762d8c547b48&quot;,&quot;parentUUID&quot;:&quot;cb5165c7-904a-47c9-8614-b3dd74554bd3&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should emit connected event with socket ID&quot;,&quot;fullTitle&quot;:&quot;Connection Tests Connection Events should emit connected event with socket ID&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = new TestClient();\nlet emittedSocketId = null;\n\nclient.on(&#x27;connected&#x27;, (socketId) =&gt; {\n    emittedSocketId = socketId;\n});\n\nconst connectedSocketId = await client.connect();\n\nexpect(emittedSocketId).to.equal(connectedSocketId);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4ce2980b-c58c-43eb-a53a-90d5262fa19e&quot;,&quot;parentUUID&quot;:&quot;cb5165c7-904a-47c9-8614-b3dd74554bd3&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should emit disconnected event&quot;,&quot;fullTitle&quot;:&quot;Connection Tests Connection Events should emit disconnected event&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = new TestClient();\nlet disconnectedEmitted = false;\n\nclient.on(&#x27;disconnected&#x27;, () =&gt; {\n    disconnectedEmitted = true;\n});\n\nawait client.connect();\nawait client.disconnect();\n\nexpect(disconnectedEmitted).to.be.true;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4a583167-4dc7-425a-8b3d-d8b0e81a9751&quot;,&quot;parentUUID&quot;:&quot;cb5165c7-904a-47c9-8614-b3dd74554bd3&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;95dcef7e-f608-4ef1-8ea4-762d8c547b48&quot;,&quot;4ce2980b-c58c-43eb-a53a-90d5262fa19e&quot;,&quot;4a583167-4dc7-425a-8b3d-d8b0e81a9751&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:106,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:15000},{&quot;uuid&quot;:&quot;32f648c6-bc87-4746-baae-9576349fc31d&quot;,&quot;title&quot;:&quot;Connection Limits&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/connection.test.js&quot;,&quot;file&quot;:&quot;/tests/connection.test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[{&quot;title&quot;:&quot;\&quot;after each\&quot; hook in \&quot;Connection Limits\&quot;&quot;,&quot;fullTitle&quot;:&quot;Connection Tests Connection Limits \&quot;after each\&quot; hook in \&quot;Connection Limits\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:0,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await TestUtils.cleanupClients(clients);\nclients = [];&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b5f48042-8cca-48cb-b6ce-72a1492094a3&quot;,&quot;parentUUID&quot;:&quot;32f648c6-bc87-4746-baae-9576349fc31d&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;tests&quot;:[{&quot;title&quot;:&quot;should respect max connections per app limit&quot;,&quot;fullTitle&quot;:&quot;Connection Tests Connection Limits should respect max connections per app limit&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:18,&quot;state&quot;:&quot;failed&quot;,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;code&quot;:&quot;// This test assumes the app is configured with a specific max_connections limit\n// The actual limit should be configured in the test environment\nconst maxConnections = 100; // This should match the test app configuration\n\ntry {\n    // Try to create more connections than allowed\n    for (let i = 0; i &lt; maxConnections + 5; i++) {\n        const client = new TestClient();\n        await client.connect();\n        clients.push(client);\n    }\n    \n    // If we get here without error, the limit might not be enforced\n    // or is higher than expected\n    console.warn(&#x27;Connection limit not enforced or higher than expected&#x27;);\n    \n} catch (error) {\n    // Expected behavior - connection should be rejected after limit\n    expect(error).to.be.an(&#x27;error&#x27;);\n    expect(clients.length).to.be.at.most(maxConnections);\n}&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;Error: Unhandled error. ({\n  type: &#x27;WebSocketError&#x27;,\n  error: { type: &#x27;PusherError&#x27;, data: { code: 1006, message: undefined } }\n})&quot;,&quot;estack&quot;:&quot;Error [ERR_UNHANDLED_ERROR]: Unhandled error. ({\n  type: &#x27;WebSocketError&#x27;,\n  error: { type: &#x27;PusherError&#x27;, data: { code: 1006, message: undefined } }\n})\n    at TestClient.emit (node:events:507:17)\n    at /var/www/sockudo/test/integration/lib/TestClient.js:44:22\n    at connection_manager_ConnectionManager.emit (node_modules/pusher-js/dist/node/pusher.js:7669:33)\n    at Object.backoff (node_modules/pusher-js/dist/node/pusher.js:8907:26)\n    at callback (node_modules/pusher-js/dist/node/pusher.js:8794:62)\n    at cb (node_modules/pusher-js/dist/node/pusher.js:9283:17)\n    at /var/www/sockudo/test/integration/node_modules/pusher-js/dist/node/pusher.js:9406:13\n    at /var/www/sockudo/test/integration/node_modules/pusher-js/dist/node/pusher.js:9195:17\n    at tryNextStrategy (node_modules/pusher-js/dist/node/pusher.js:9106:17)\n    at /var/www/sockudo/test/integration/node_modules/pusher-js/dist/node/pusher.js:9156:13\n    at handshake_Handshake.callback (node_modules/pusher-js/dist/node/pusher.js:10163:17)\n    at handshake_Handshake.finish (node_modules/pusher-js/dist/node/pusher.js:8234:14)\n    at onClosed (node_modules/pusher-js/dist/node/pusher.js:8224:18)\n    at transport_connection_TransportConnection.emit (node_modules/pusher-js/dist/node/pusher.js:7669:33)\n    at transport_connection_TransportConnection.changeState (node_modules/pusher-js/dist/node/pusher.js:7868:14)\n    at transport_connection_TransportConnection.onClose (node_modules/pusher-js/dist/node/pusher.js:7814:18)\n    at socket.onclose (node_modules/pusher-js/dist/node/pusher.js:7840:18)\n    at Client.dispatchEvent (node_modules/pusher-js/dist/node/pusher.js:1908:30)\n    at Client._finalizeClose (node_modules/pusher-js/dist/node/pusher.js:1133:10)\n    at Socket.&lt;anonymous&gt; (node_modules/pusher-js/dist/node/pusher.js:1068:48)\n    at Socket.emit (node:events:530:35)\n    at endReadableNT (node:internal/streams/readable:1698:12)\n    at process.processTicksAndRejections (node:internal/process/task_queues:90:21)&quot;},&quot;uuid&quot;:&quot;d16506e7-6592-4ce9-b387-75fe900b083f&quot;,&quot;parentUUID&quot;:&quot;32f648c6-bc87-4746-baae-9576349fc31d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[],&quot;failures&quot;:[&quot;d16506e7-6592-4ce9-b387-75fe900b083f&quot;],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:18,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:15000},{&quot;uuid&quot;:&quot;1a3cb663-c6e7-40b4-9cd1-2036de7a0f80&quot;,&quot;title&quot;:&quot;Connection Persistence&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/connection.test.js&quot;,&quot;file&quot;:&quot;/tests/connection.test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should maintain connection during idle periods&quot;,&quot;fullTitle&quot;:&quot;Connection Tests Connection Persistence should maintain connection during idle periods&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5003,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = new TestClient();\nawait client.connect();\n\nconst initialSocketId = client.getSocketId();\nexpect(client.isConnected()).to.be.true;\n\n// Wait for 5 seconds (idle period)\nawait TestUtils.wait(5000);\n\n// Connection should still be active\nexpect(client.isConnected()).to.be.true;\nexpect(client.getSocketId()).to.equal(initialSocketId);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;002eb732-d7f3-49c4-abe0-6ef7610848d1&quot;,&quot;parentUUID&quot;:&quot;1a3cb663-c6e7-40b4-9cd1-2036de7a0f80&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should handle ping/pong to keep connection alive&quot;,&quot;fullTitle&quot;:&quot;Connection Tests Connection Persistence should handle ping/pong to keep connection alive&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3004,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;client = new TestClient();\nawait client.connect();\n\n// Pusher protocol uses ping/pong automatically\n// Wait for multiple ping/pong cycles (typically 30 seconds)\n// For testing, we&#x27;ll just verify connection stays alive\nawait TestUtils.wait(3000);\n\nexpect(client.isConnected()).to.be.true;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;64490272-b473-43ce-a63b-959146bf605c&quot;,&quot;parentUUID&quot;:&quot;1a3cb663-c6e7-40b4-9cd1-2036de7a0f80&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;002eb732-d7f3-49c4-abe0-6ef7610848d1&quot;,&quot;64490272-b473-43ce-a63b-959146bf605c&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:8007,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:15000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:15000},{&quot;uuid&quot;:&quot;f9e88b74-2c5a-426f-b701-e3b361d1ec79&quot;,&quot;title&quot;:&quot;Event Broadcasting Tests&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/events.test.js&quot;,&quot;file&quot;:&quot;/tests/events.test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[{&quot;title&quot;:&quot;\&quot;after each\&quot; hook in \&quot;Event Broadcasting Tests\&quot;&quot;,&quot;fullTitle&quot;:&quot;Event Broadcasting Tests \&quot;after each\&quot; hook in \&quot;Event Broadcasting Tests\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:0,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;if (client1 &amp;&amp; client1.isConnected()) {\n    await client1.disconnect();\n}\nif (client2 &amp;&amp; client2.isConnected()) {\n    await client2.disconnect();\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;54391677-cedd-4bd7-96a4-a3f84fe0ec83&quot;,&quot;parentUUID&quot;:&quot;f9e88b74-2c5a-426f-b701-e3b361d1ec79&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;0f2384ae-14cb-4a81-b5fa-11110e348527&quot;,&quot;title&quot;:&quot;HTTP API Event Broadcasting&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/events.test.js&quot;,&quot;file&quot;:&quot;/tests/events.test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should broadcast events to subscribed clients&quot;,&quot;fullTitle&quot;:&quot;Event Broadcasting Tests HTTP API Event Broadcasting should broadcast events to subscribed clients&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:13,&quot;state&quot;:&quot;failed&quot;,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = TestUtils.generateChannelName(&#x27;broadcast-test&#x27;);\nconst eventName = &#x27;test-event&#x27;;\nconst eventData = { message: &#x27;Hello World&#x27;, timestamp: Date.now() };\n// Set up client to receive events\nclient1 = new TestClient();\nawait client1.connect();\nawait client1.subscribe(channelName);\n// Set up event listener\nconst eventPromise = client1.waitForEvent(channelName, eventName, 5000);\n// Send event via HTTP API\nawait TestUtils.sendApiEvent({\n    channels: channelName,\n    event: eventName,\n    data: eventData\n});\n// Verify event was received\nconst receivedData = await eventPromise;\nexpect(receivedData).to.deep.equal(eventData);&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;Error: API event failed: 400 - {\&quot;error\&quot;:\&quot;Missing authentication query parameters\&quot;}&quot;,&quot;estack&quot;:&quot;Error: API event failed: 400 - {\&quot;error\&quot;:\&quot;Missing authentication query parameters\&quot;}\n    at TestUtils.sendApiEvent (lib/TestUtils.js:120:19)\n    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)\n    at async Context.&lt;anonymous&gt; (tests/events.test.js:34:13)&quot;},&quot;uuid&quot;:&quot;bec7b314-95cc-4c12-b029-c2df5a1d18c5&quot;,&quot;parentUUID&quot;:&quot;0f2384ae-14cb-4a81-b5fa-11110e348527&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should broadcast to multiple channels simultaneously&quot;,&quot;fullTitle&quot;:&quot;Event Broadcasting Tests HTTP API Event Broadcasting should broadcast to multiple channels simultaneously&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9,&quot;state&quot;:&quot;failed&quot;,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channels = [\n    TestUtils.generateChannelName(&#x27;multi-1&#x27;),\n    TestUtils.generateChannelName(&#x27;multi-2&#x27;)\n];\nconst eventName = &#x27;multi-channel-event&#x27;;\nconst eventData = { message: &#x27;Multi-channel broadcast&#x27; };\n// Set up clients for each channel\nclient1 = new TestClient();\nawait client1.connect();\nawait client1.subscribe(channels[0]);\nclient2 = new TestClient();\nawait client2.connect();\nawait client2.subscribe(channels[1]);\n// Set up event listeners\nconst event1Promise = client1.waitForEvent(channels[0], eventName);\nconst event2Promise = client2.waitForEvent(channels[1], eventName);\n// Broadcast to both channels\nawait TestUtils.sendApiEvent({\n    channels: channels,\n    event: eventName,\n    data: eventData\n});\n// Verify both clients received the event\nconst [data1, data2] = await Promise.all([event1Promise, event2Promise]);\nexpect(data1).to.deep.equal(eventData);\nexpect(data2).to.deep.equal(eventData);&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;Error: API event failed: 400 - {\&quot;error\&quot;:\&quot;Missing authentication query parameters\&quot;}&quot;,&quot;estack&quot;:&quot;Error: API event failed: 400 - {\&quot;error\&quot;:\&quot;Missing authentication query parameters\&quot;}\n    at TestUtils.sendApiEvent (lib/TestUtils.js:120:19)\n    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)\n    at async Context.&lt;anonymous&gt; (tests/events.test.js:67:13)&quot;},&quot;uuid&quot;:&quot;0b11dd09-0370-4fb6-9852-709d5cb12b79&quot;,&quot;parentUUID&quot;:&quot;0f2384ae-14cb-4a81-b5fa-11110e348527&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should not send events to unsubscribed clients&quot;,&quot;fullTitle&quot;:&quot;Event Broadcasting Tests HTTP API Event Broadcasting should not send events to unsubscribed clients&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3,&quot;state&quot;:&quot;failed&quot;,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = TestUtils.generateChannelName(&#x27;no-sub-test&#x27;);\nconst eventName = &#x27;should-not-receive&#x27;;\nconst eventData = { message: &#x27;Should not be received&#x27; };\n// Set up client but don&#x27;t subscribe\nclient1 = new TestClient();\nawait client1.connect();\n// Try to listen for event (should timeout)\nlet eventReceived = false;\nconst channel = client1.getChannel(channelName);\nif (channel) {\n    channel.bind(eventName, () =&gt; {\n        eventReceived = true;\n    });\n}\n// Send event\nawait TestUtils.sendApiEvent({\n    channels: channelName,\n    event: eventName,\n    data: eventData\n});\n// Wait a bit to ensure no event is received\nawait TestUtils.wait(2000);\nexpect(eventReceived).to.be.false;&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;Error: API event failed: 400 - {\&quot;error\&quot;:\&quot;Missing authentication query parameters\&quot;}&quot;,&quot;estack&quot;:&quot;Error: API event failed: 400 - {\&quot;error\&quot;:\&quot;Missing authentication query parameters\&quot;}\n    at TestUtils.sendApiEvent (lib/TestUtils.js:120:19)\n    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)\n    at async Context.&lt;anonymous&gt; (tests/events.test.js:98:13)&quot;},&quot;uuid&quot;:&quot;a28bad17-c68d-43dc-92f0-2f65a8aafec6&quot;,&quot;parentUUID&quot;:&quot;0f2384ae-14cb-4a81-b5fa-11110e348527&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should handle large payloads within limits&quot;,&quot;fullTitle&quot;:&quot;Event Broadcasting Tests HTTP API Event Broadcasting should handle large payloads within limits&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:7,&quot;state&quot;:&quot;failed&quot;,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = TestUtils.generateChannelName(&#x27;large-payload&#x27;);\nconst eventName = &#x27;large-event&#x27;;\n\n// Generate ~50KB payload (within typical limits)\nconst largeData = {\n    message: &#x27;Large payload test&#x27;,\n    data: TestUtils.generateLargePayload(50) // 50KB\n};\nclient1 = new TestClient();\nawait client1.connect();\nawait client1.subscribe(channelName);\nconst eventPromise = client1.waitForEvent(channelName, eventName);\nawait TestUtils.sendApiEvent({\n    channels: channelName,\n    event: eventName,\n    data: largeData\n});\nconst receivedData = await eventPromise;\nexpect(receivedData.message).to.equal(largeData.message);\nexpect(receivedData.data.length).to.equal(largeData.data.length);&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;Error: API event failed: 400 - {\&quot;error\&quot;:\&quot;Missing authentication query parameters\&quot;}&quot;,&quot;estack&quot;:&quot;Error: API event failed: 400 - {\&quot;error\&quot;:\&quot;Missing authentication query parameters\&quot;}\n    at TestUtils.sendApiEvent (lib/TestUtils.js:120:19)\n    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)\n    at async Context.&lt;anonymous&gt; (tests/events.test.js:125:13)&quot;},&quot;uuid&quot;:&quot;6547820b-3aed-45e0-a5f0-dd9db9b6a3c7&quot;,&quot;parentUUID&quot;:&quot;0f2384ae-14cb-4a81-b5fa-11110e348527&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should reject oversized payloads&quot;,&quot;fullTitle&quot;:&quot;Event Broadcasting Tests HTTP API Event Broadcasting should reject oversized payloads&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2288,&quot;state&quot;:&quot;failed&quot;,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = TestUtils.generateChannelName(&#x27;oversized&#x27;);\nconst eventName = &#x27;oversized-event&#x27;;\n\n// Generate payload larger than limit (assuming 1MB limit)\nconst oversizedData = {\n    data: TestUtils.generateLargePayload(1100) // 1.1MB\n};\ntry {\n    await TestUtils.sendApiEvent({\n        channels: channelName,\n        event: eventName,\n        data: oversizedData\n    });\n    expect.fail(&#x27;Should have thrown an error for oversized payload&#x27;);\n} catch (error) {\n    expect(error.message).to.include(&#x27;413&#x27;);\n}&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;AssertionError: expected &#x27;API event failed: 400 - {\&quot;error\&quot;:\&quot;Mis…&#x27; to include &#x27;413&#x27;&quot;,&quot;estack&quot;:&quot;AssertionError: expected &#x27;API event failed: 400 - {\&quot;error\&quot;:\&quot;Mis…&#x27; to include &#x27;413&#x27;\n    at Context.&lt;anonymous&gt; (tests/events.test.js:153:42)\n    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)&quot;},&quot;uuid&quot;:&quot;e4ed1c93-18fd-4efa-bf15-104649acc312&quot;,&quot;parentUUID&quot;:&quot;0f2384ae-14cb-4a81-b5fa-11110e348527&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[],&quot;failures&quot;:[&quot;bec7b314-95cc-4c12-b029-c2df5a1d18c5&quot;,&quot;0b11dd09-0370-4fb6-9852-709d5cb12b79&quot;,&quot;a28bad17-c68d-43dc-92f0-2f65a8aafec6&quot;,&quot;6547820b-3aed-45e0-a5f0-dd9db9b6a3c7&quot;,&quot;e4ed1c93-18fd-4efa-bf15-104649acc312&quot;],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:2320,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:15000},{&quot;uuid&quot;:&quot;8e4fc501-2100-4e7a-8fad-faa7787a9349&quot;,&quot;title&quot;:&quot;Client Event Broadcasting&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/events.test.js&quot;,&quot;file&quot;:&quot;/tests/events.test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should broadcast client events on private channels&quot;,&quot;fullTitle&quot;:&quot;Event Broadcasting Tests Client Event Broadcasting should broadcast client events on private channels&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:53,&quot;state&quot;:&quot;failed&quot;,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = &#x27;private-client-events&#x27;;\nconst eventName = &#x27;client-test-event&#x27;;\nconst eventData = { message: &#x27;Client event test&#x27;, sender: &#x27;client1&#x27; };\n// Set up two clients\nclient1 = new TestClient();\nawait client1.connect();\nawait client1.subscribe(channelName);\nclient2 = new TestClient();\nawait client2.connect();\nawait client2.subscribe(channelName);\n// Set up event listener on client2\nconst eventPromise = client2.waitForEvent(channelName, eventName);\n// Client1 sends event\nawait client1.trigger(channelName, eventName, eventData);\n// Verify client2 received the event\nconst receivedData = await eventPromise;\nexpect(receivedData).to.deep.equal(eventData);&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;AssertionError: expected null to deeply equal { message: &#x27;Client event test&#x27;, …(1) }&quot;,&quot;estack&quot;:&quot;AssertionError: expected null to deeply equal { message: &#x27;Client event test&#x27;, …(1) }\n    at Context.&lt;anonymous&gt; (tests/events.test.js:181:42)\n    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)&quot;},&quot;uuid&quot;:&quot;bec16a21-7861-4bbe-a7f0-e334e44641e1&quot;,&quot;parentUUID&quot;:&quot;8e4fc501-2100-4e7a-8fad-faa7787a9349&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should broadcast client events on presence channels&quot;,&quot;fullTitle&quot;:&quot;Event Broadcasting Tests Client Event Broadcasting should broadcast client events on presence channels&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:56,&quot;state&quot;:&quot;failed&quot;,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = &#x27;presence-client-events&#x27;;\nconst eventName = &#x27;client-presence-event&#x27;;\nconst eventData = { message: &#x27;Presence client event&#x27; };\nclient1 = new TestClient();\nawait client1.connect();\nawait client1.subscribe(channelName);\nclient2 = new TestClient();\nawait client2.connect();\nawait client2.subscribe(channelName);\nconst eventPromise = client2.waitForEvent(channelName, eventName);\nawait client1.trigger(channelName, eventName, eventData);\nconst receivedData = await eventPromise;\nexpect(receivedData).to.deep.equal(eventData);&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;AssertionError: expected null to deeply equal { message: &#x27;Presence client event&#x27; }&quot;,&quot;estack&quot;:&quot;AssertionError: expected null to deeply equal { message: &#x27;Presence client event&#x27; }\n    at Context.&lt;anonymous&gt; (tests/events.test.js:202:42)\n    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)&quot;},&quot;uuid&quot;:&quot;bff3f390-2b1e-4980-8563-e22299d390ed&quot;,&quot;parentUUID&quot;:&quot;8e4fc501-2100-4e7a-8fad-faa7787a9349&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should not allow client events on public channels&quot;,&quot;fullTitle&quot;:&quot;Event Broadcasting Tests Client Event Broadcasting should not allow client events on public channels&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = &#x27;public-no-client-events&#x27;;\nclient1 = new TestClient();\nawait client1.connect();\nawait client1.subscribe(channelName);\ntry {\n    await client1.trigger(channelName, &#x27;client-event&#x27;, { data: &#x27;test&#x27; });\n    expect.fail(&#x27;Should have thrown an error&#x27;);\n} catch (error) {\n    expect(error.message).to.include(&#x27;Client events only supported on private/presence channels&#x27;);\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;84a1d857-2a36-41ad-bf6e-931a9299f6e0&quot;,&quot;parentUUID&quot;:&quot;8e4fc501-2100-4e7a-8fad-faa7787a9349&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should enforce client event rate limits&quot;,&quot;fullTitle&quot;:&quot;Event Broadcasting Tests Client Event Broadcasting should enforce client event rate limits&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5,&quot;state&quot;:&quot;failed&quot;,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = &#x27;private-rate-limit-test&#x27;;\nconst eventName = &#x27;rate-limit-event&#x27;;\nclient1 = new TestClient();\nawait client1.connect();\nawait client1.subscribe(channelName);\n// Send events rapidly to trigger rate limit\nconst promises = [];\nfor (let i = 0; i &lt; 20; i++) {\n    promises.push(\n        client1.trigger(channelName, eventName, { id: i })\n            .catch(error =&gt; error)\n    );\n}\nconst results = await Promise.all(promises);\n\n// Some should succeed, some should be rate limited\nconst errors = results.filter(r =&gt; r instanceof Error);\nconst successes = results.filter(r =&gt; !(r instanceof Error));\n\nexpect(errors.length).to.be.greaterThan(0);\nexpect(successes.length).to.be.greaterThan(0);&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;AssertionError: expected +0 to be above +0&quot;,&quot;estack&quot;:&quot;AssertionError: expected +0 to be above +0\n    at Context.&lt;anonymous&gt; (tests/events.test.js:244:44)\n    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)&quot;,&quot;diff&quot;:&quot;&quot;},&quot;uuid&quot;:&quot;a097982a-e120-4c53-9582-7e0e769233fc&quot;,&quot;parentUUID&quot;:&quot;8e4fc501-2100-4e7a-8fad-faa7787a9349&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;84a1d857-2a36-41ad-bf6e-931a9299f6e0&quot;],&quot;failures&quot;:[&quot;bec16a21-7861-4bbe-a7f0-e334e44641e1&quot;,&quot;bff3f390-2b1e-4980-8563-e22299d390ed&quot;,&quot;a097982a-e120-4c53-9582-7e0e769233fc&quot;],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:118,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:15000},{&quot;uuid&quot;:&quot;459dd103-9ac0-43d6-a867-90ff11a3259e&quot;,&quot;title&quot;:&quot;Event Filtering and Targeting&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/events.test.js&quot;,&quot;file&quot;:&quot;/tests/events.test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should only send events to subscribed channels&quot;,&quot;fullTitle&quot;:&quot;Event Broadcasting Tests Event Filtering and Targeting should only send events to subscribed channels&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9,&quot;state&quot;:&quot;failed&quot;,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;code&quot;:&quot;const targetChannel = TestUtils.generateChannelName(&#x27;target&#x27;);\nconst otherChannel = TestUtils.generateChannelName(&#x27;other&#x27;);\nconst eventName = &#x27;targeted-event&#x27;;\nconst eventData = { message: &#x27;Only for target channel&#x27; };\n// Client1 subscribes to target channel\nclient1 = new TestClient();\nawait client1.connect();\nawait client1.subscribe(targetChannel);\n// Client2 subscribes to other channel\nclient2 = new TestClient();\nawait client2.connect();\nawait client2.subscribe(otherChannel);\n// Set up listeners\nlet client1Received = false;\nlet client2Received = false;\nclient1.getChannel(targetChannel).bind(eventName, () =&gt; {\n    client1Received = true;\n});\nclient2.getChannel(otherChannel).bind(eventName, () =&gt; {\n    client2Received = true;\n});\n// Send event only to target channel\nawait TestUtils.sendApiEvent({\n    channels: targetChannel,\n    event: eventName,\n    data: eventData\n});\n// Wait for potential delivery\nawait TestUtils.wait(1000);\nexpect(client1Received).to.be.true;\nexpect(client2Received).to.be.false;&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;Error: API event failed: 400 - {\&quot;error\&quot;:\&quot;Missing authentication query parameters\&quot;}&quot;,&quot;estack&quot;:&quot;Error: API event failed: 400 - {\&quot;error\&quot;:\&quot;Missing authentication query parameters\&quot;}\n    at TestUtils.sendApiEvent (lib/TestUtils.js:120:19)\n    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)\n    at async Context.&lt;anonymous&gt; (tests/events.test.js:278:13)&quot;},&quot;uuid&quot;:&quot;c13b645c-60c1-40a6-9cd0-f55c615187c7&quot;,&quot;parentUUID&quot;:&quot;459dd103-9ac0-43d6-a867-90ff11a3259e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should handle event name validation&quot;,&quot;fullTitle&quot;:&quot;Event Broadcasting Tests Event Filtering and Targeting should handle event name validation&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:7,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = TestUtils.generateChannelName(&#x27;validation&#x27;);\n\nclient1 = new TestClient();\nawait client1.connect();\nawait client1.subscribe(channelName);\n// Test invalid event names\nconst invalidNames = [&#x27;&#x27;, &#x27;a&#x27;.repeat(201), &#x27;invalid#name&#x27;];\n\nfor (const invalidName of invalidNames) {\n    try {\n        await TestUtils.sendApiEvent({\n            channels: channelName,\n            event: invalidName,\n            data: { test: true }\n        });\n        expect.fail(`Should have rejected event name: ${invalidName}`);\n    } catch (error) {\n        expect(error).to.be.an(&#x27;error&#x27;);\n    }\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6086cb65-8b62-4b89-b7a5-5514b83d788e&quot;,&quot;parentUUID&quot;:&quot;459dd103-9ac0-43d6-a867-90ff11a3259e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;6086cb65-8b62-4b89-b7a5-5514b83d788e&quot;],&quot;failures&quot;:[&quot;c13b645c-60c1-40a6-9cd0-f55c615187c7&quot;],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:16,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:15000},{&quot;uuid&quot;:&quot;3c080f0f-7929-4b53-a47f-da0ad77c6311&quot;,&quot;title&quot;:&quot;Event Latency and Performance&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/events.test.js&quot;,&quot;file&quot;:&quot;/tests/events.test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should deliver events with reasonable latency&quot;,&quot;fullTitle&quot;:&quot;Event Broadcasting Tests Event Latency and Performance should deliver events with reasonable latency&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:6,&quot;state&quot;:&quot;failed&quot;,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = TestUtils.generateChannelName(&#x27;latency&#x27;);\nconst eventName = &#x27;latency-test&#x27;;\nclient1 = new TestClient();\nawait client1.connect();\nawait client1.subscribe(channelName);\nclient2 = new TestClient();\nawait client2.connect();\nawait client2.subscribe(channelName);\n// Measure latency using client events\nconst latency = await TestUtils.measureLatency(client1, client2, channelName);\n\n// Latency should be reasonable (less than 100ms for local test)\nexpect(latency).to.be.lessThan(100);&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;Error: Client events only supported on private/presence channels&quot;,&quot;estack&quot;:&quot;Error: Client events only supported on private/presence channels\n    at TestClient.trigger (lib/TestClient.js:108:19)\n    at TestUtils.measureLatency (lib/TestUtils.js:257:28)\n    at Context.&lt;anonymous&gt; (tests/events.test.js:330:45)\n    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)&quot;},&quot;uuid&quot;:&quot;62366b98-c2d0-4d8d-a7fd-253e4c6efb66&quot;,&quot;parentUUID&quot;:&quot;3c080f0f-7929-4b53-a47f-da0ad77c6311&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should handle burst event delivery&quot;,&quot;fullTitle&quot;:&quot;Event Broadcasting Tests Event Latency and Performance should handle burst event delivery&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:7,&quot;state&quot;:&quot;failed&quot;,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = TestUtils.generateChannelName(&#x27;burst&#x27;);\nconst eventName = &#x27;burst-event&#x27;;\nconst eventCount = 10;\nclient1 = new TestClient();\nawait client1.connect();\nawait client1.subscribe(channelName);\nconst receivedEvents = [];\nclient1.getChannel(channelName).bind(eventName, (data) =&gt; {\n    receivedEvents.push(data);\n});\n// Send burst of events\nconst promises = [];\nfor (let i = 0; i &lt; eventCount; i++) {\n    promises.push(\n        TestUtils.sendApiEvent({\n            channels: channelName,\n            event: eventName,\n            data: { id: i, message: `Event ${i}` }\n        })\n    );\n}\nawait Promise.all(promises);\n// Wait for all events to be delivered\nawait TestUtils.wait(2000);\nexpect(receivedEvents).to.have.lengthOf(eventCount);\n\n// Verify all events were received in order\nfor (let i = 0; i &lt; eventCount; i++) {\n    const event = receivedEvents.find(e =&gt; e.id === i);\n    expect(event).to.exist;\n    expect(event.message).to.equal(`Event ${i}`);\n}&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;Error: API event failed: 400 - {\&quot;error\&quot;:\&quot;Missing authentication query parameters\&quot;}&quot;,&quot;estack&quot;:&quot;Error: API event failed: 400 - {\&quot;error\&quot;:\&quot;Missing authentication query parameters\&quot;}\n    at TestUtils.sendApiEvent (lib/TestUtils.js:120:19)\n    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)\n    at async Promise.all (index 0)\n    at async Context.&lt;anonymous&gt; (tests/events.test.js:362:13)&quot;},&quot;uuid&quot;:&quot;51468b59-395c-4518-9bf9-df48955cb61f&quot;,&quot;parentUUID&quot;:&quot;3c080f0f-7929-4b53-a47f-da0ad77c6311&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[],&quot;failures&quot;:[&quot;62366b98-c2d0-4d8d-a7fd-253e4c6efb66&quot;,&quot;51468b59-395c-4518-9bf9-df48955cb61f&quot;],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:13,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:15000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:15000},{&quot;uuid&quot;:&quot;b1ac07fb-e22c-4e83-b39e-70ec19c3aa7b&quot;,&quot;title&quot;:&quot;Quota and Limits Tests&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/quotas.test.js&quot;,&quot;file&quot;:&quot;/tests/quotas.test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[{&quot;title&quot;:&quot;\&quot;after each\&quot; hook in \&quot;Quota and Limits Tests\&quot;&quot;,&quot;fullTitle&quot;:&quot;Quota and Limits Tests \&quot;after each\&quot; hook in \&quot;Quota and Limits Tests\&quot;&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:0,&quot;pass&quot;:false,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;await TestUtils.cleanupClients(clients);\nclients = [];&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;12805877-ebe5-4a6d-a736-77397b63bdbc&quot;,&quot;parentUUID&quot;:&quot;b1ac07fb-e22c-4e83-b39e-70ec19c3aa7b&quot;,&quot;isHook&quot;:true,&quot;skipped&quot;:false}],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;64632e9b-978d-40c9-a4ac-b7789cd95e4b&quot;,&quot;title&quot;:&quot;Connection Limits&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/quotas.test.js&quot;,&quot;file&quot;:&quot;/tests/quotas.test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should enforce max connections per app&quot;,&quot;fullTitle&quot;:&quot;Quota and Limits Tests Connection Limits should enforce max connections per app&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:14,&quot;state&quot;:&quot;failed&quot;,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;code&quot;:&quot;const maxConnections = 10; // Based on test configuration\n\n// Step 1: Connect up to max_connections\nconsole.log(`Connecting up to ${maxConnections} clients...`);\nfor (let i = 0; i &lt; maxConnections; i++) {\n    const client = new TestClient();\n    await client.connect();\n    clients.push(client);\n}\n\nexpect(clients).to.have.lengthOf(maxConnections);\nconsole.log(`Successfully connected ${clients.length} clients`);\n\n// Step 2: Confirm quota error on the next connection\nconsole.log(&#x27;Testing quota enforcement...&#x27;);\nlet quotaErrorReceived = false;\ntry {\n    const extraClient = new TestClient();\n    await extraClient.connect();\n    // If we get here, the limit wasn&#x27;t enforced\n    await extraClient.disconnect();\n    expect.fail(&#x27;Should have hit connection limit&#x27;);\n} catch (error) {\n    quotaErrorReceived = true;\n    console.log(`Got expected quota error: ${error.message}`);\n}\n\nexpect(quotaErrorReceived).to.be.true;\n\n// Step 3: Free a small amount of connections (3)\nconst connectionsToFree = 3;\nconsole.log(`Freeing ${connectionsToFree} connections...`);\nfor (let i = 0; i &lt; connectionsToFree; i++) {\n    await clients.pop().disconnect();\n}\n\n// Wait for server to process disconnections\nawait TestUtils.wait(1000);\n\n// Step 4: Ensure we can reconnect up to X connections\nconsole.log(`Reconnecting ${connectionsToFree} clients...`);\nfor (let i = 0; i &lt; connectionsToFree; i++) {\n    const client = new TestClient();\n    await client.connect();\n    clients.push(client);\n}\n\nexpect(clients).to.have.lengthOf(maxConnections);\n\n// Step 5: Confirm hitting quota again\nconsole.log(&#x27;Confirming quota is enforced again...&#x27;);\ntry {\n    const extraClient = new TestClient();\n    await extraClient.connect();\n    await extraClient.disconnect();\n    expect.fail(&#x27;Should have hit connection limit again&#x27;);\n} catch (error) {\n    console.log(`Got expected quota error again: ${error.message}`);\n}&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;Error: Unhandled error. ({\n  type: &#x27;WebSocketError&#x27;,\n  error: { type: &#x27;PusherError&#x27;, data: { code: 1006, message: undefined } }\n})&quot;,&quot;estack&quot;:&quot;Error [ERR_UNHANDLED_ERROR]: Unhandled error. ({\n  type: &#x27;WebSocketError&#x27;,\n  error: { type: &#x27;PusherError&#x27;, data: { code: 1006, message: undefined } }\n})\n    at TestClient.emit (node:events:507:17)\n    at /var/www/sockudo/test/integration/lib/TestClient.js:44:22\n    at connection_manager_ConnectionManager.emit (node_modules/pusher-js/dist/node/pusher.js:7669:33)\n    at Object.backoff (node_modules/pusher-js/dist/node/pusher.js:8907:26)\n    at callback (node_modules/pusher-js/dist/node/pusher.js:8794:62)\n    at cb (node_modules/pusher-js/dist/node/pusher.js:9283:17)\n    at /var/www/sockudo/test/integration/node_modules/pusher-js/dist/node/pusher.js:9406:13\n    at /var/www/sockudo/test/integration/node_modules/pusher-js/dist/node/pusher.js:9195:17\n    at tryNextStrategy (node_modules/pusher-js/dist/node/pusher.js:9106:17)\n    at /var/www/sockudo/test/integration/node_modules/pusher-js/dist/node/pusher.js:9156:13\n    at handshake_Handshake.callback (node_modules/pusher-js/dist/node/pusher.js:10163:17)\n    at handshake_Handshake.finish (node_modules/pusher-js/dist/node/pusher.js:8234:14)\n    at onClosed (node_modules/pusher-js/dist/node/pusher.js:8224:18)\n    at transport_connection_TransportConnection.emit (node_modules/pusher-js/dist/node/pusher.js:7669:33)\n    at transport_connection_TransportConnection.changeState (node_modules/pusher-js/dist/node/pusher.js:7868:14)\n    at transport_connection_TransportConnection.onClose (node_modules/pusher-js/dist/node/pusher.js:7814:18)\n    at socket.onclose (node_modules/pusher-js/dist/node/pusher.js:7840:18)\n    at Client.dispatchEvent (node_modules/pusher-js/dist/node/pusher.js:1908:30)\n    at Client._finalizeClose (node_modules/pusher-js/dist/node/pusher.js:1133:10)\n    at Socket.&lt;anonymous&gt; (node_modules/pusher-js/dist/node/pusher.js:1068:48)\n    at Socket.emit (node:events:530:35)\n    at endReadableNT (node:internal/streams/readable:1698:12)\n    at process.processTicksAndRejections (node:internal/process/task_queues:90:21)&quot;},&quot;uuid&quot;:&quot;b377019b-07b2-4c13-8303-aa1184fc1056&quot;,&quot;parentUUID&quot;:&quot;64632e9b-978d-40c9-a4ac-b7789cd95e4b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should allow new connections after others disconnect&quot;,&quot;fullTitle&quot;:&quot;Quota and Limits Tests Connection Limits should allow new connections after others disconnect&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1011,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;// Create some initial connections\nconst initialCount = 5;\nfor (let i = 0; i &lt; initialCount; i++) {\n    const client = new TestClient();\n    await client.connect();\n    clients.push(client);\n}\nexpect(clients).to.have.lengthOf(initialCount);\n// Disconnect half of them\nconst toDisconnect = Math.floor(initialCount / 2);\nfor (let i = 0; i &lt; toDisconnect; i++) {\n    await clients[i].disconnect();\n}\n// Wait for server to process disconnections\nawait TestUtils.wait(1000);\n// Should be able to create new connections\nconst newClient = new TestClient();\nawait newClient.connect();\nclients.push(newClient);\nexpect(newClient.isConnected()).to.be.true;&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6def9192-f6b4-485d-bd63-b33c7e3199fd&quot;,&quot;parentUUID&quot;:&quot;64632e9b-978d-40c9-a4ac-b7789cd95e4b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;6def9192-f6b4-485d-bd63-b33c7e3199fd&quot;],&quot;failures&quot;:[&quot;b377019b-07b2-4c13-8303-aa1184fc1056&quot;],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:1025,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:30000},{&quot;uuid&quot;:&quot;37ba4978-86f4-4321-8f4e-befc9509f3f2&quot;,&quot;title&quot;:&quot;Event Rate Limits&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/quotas.test.js&quot;,&quot;file&quot;:&quot;/tests/quotas.test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should enforce client event rate limits and recover&quot;,&quot;fullTitle&quot;:&quot;Quota and Limits Tests Event Rate Limits should enforce client event rate limits and recover&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:6,&quot;state&quot;:&quot;failed&quot;,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = &#x27;private-rate-limit-test&#x27;;\nconst rateLimit = 5; // 5 events per second configured\n\nconst client = new TestClient();\nawait client.connect();\nawait client.subscribe(channelName);\nclients.push(client);\n// Step 1: Send events up to the rate limit\nconsole.log(`Sending ${rateLimit} events within rate limit...`);\nlet successCount = 0;\nfor (let i = 0; i &lt; rateLimit; i++) {\n    try {\n        await client.trigger(channelName, &#x27;rate-test-event&#x27;, { id: i });\n        successCount++;\n    } catch (error) {\n        // Unexpected - should be within limit\n        console.log(`Unexpected error within limit: ${error.message}`);\n    }\n}\n\nexpect(successCount).to.equal(rateLimit);\n\n// Step 2: Confirm rate limit error on the next event\nconsole.log(&#x27;Testing rate limit enforcement...&#x27;);\nlet rateLimitHit = false;\ntry {\n    await client.trigger(channelName, &#x27;rate-test-event&#x27;, { id: &#x27;over-limit&#x27; });\n} catch (error) {\n    rateLimitHit = true;\n    console.log(`Got expected rate limit error: ${error.message}`);\n}\n\nexpect(rateLimitHit).to.be.true;\n\n// Step 3: Wait for rate limit window to reset\nconsole.log(&#x27;Waiting for rate limit to reset...&#x27;);\nawait TestUtils.wait(1200); // Wait for 1+ second window reset\n\n// Step 4: Confirm we can send events again\nconsole.log(&#x27;Testing rate limit recovery...&#x27;);\nlet canSendAgain = false;\ntry {\n    await client.trigger(channelName, &#x27;after-reset&#x27;, { test: true });\n    canSendAgain = true;\n    console.log(&#x27;Successfully sent event after rate limit reset&#x27;);\n} catch (error) {\n    console.log(`Unexpected error after reset: ${error.message}`);\n}\n\nexpect(canSendAgain).to.be.true;&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;AssertionError: expected +0 to equal 5&quot;,&quot;estack&quot;:&quot;AssertionError: expected +0 to equal 5\n    at Context.&lt;anonymous&gt; (tests/quotas.test.js:130:37)\n    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)&quot;,&quot;diff&quot;:&quot;- 0\n+ 5\n&quot;},&quot;uuid&quot;:&quot;7df59602-f24e-408b-804a-1a0f6f1ae925&quot;,&quot;parentUUID&quot;:&quot;37ba4978-86f4-4321-8f4e-befc9509f3f2&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[],&quot;failures&quot;:[&quot;7df59602-f24e-408b-804a-1a0f6f1ae925&quot;],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:6,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:30000},{&quot;uuid&quot;:&quot;016e6bca-f037-45b8-aace-c6eb73f24fc5&quot;,&quot;title&quot;:&quot;Channel Limits&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/quotas.test.js&quot;,&quot;file&quot;:&quot;/tests/quotas.test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should handle multiple channel subscriptions per connection&quot;,&quot;fullTitle&quot;:&quot;Quota and Limits Tests Channel Limits should handle multiple channel subscriptions per connection&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:29,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const client = new TestClient();\nawait client.connect();\nclients.push(client);\nconst channelCount = 15; // Reasonable number for testing\nconst channels = [];\nconsole.log(`Subscribing to ${channelCount} channels...`);\nfor (let i = 0; i &lt; channelCount; i++) {\n    const channelName = TestUtils.generateChannelName(`multi-${i}`);\n    await client.subscribe(channelName);\n    channels.push(channelName);\n}\n// Verify all channels are subscribed\nexpect(client.channels.size).to.equal(channelCount);\n// Test unsubscription\nconsole.log(&#x27;Unsubscribing from all channels...&#x27;);\nfor (const channelName of channels) {\n    await client.unsubscribe(channelName);\n}\nexpect(client.channels.size).to.equal(0);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;4d9167ab-c1da-4b69-aeb3-788fcf5459be&quot;,&quot;parentUUID&quot;:&quot;016e6bca-f037-45b8-aace-c6eb73f24fc5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should allow reasonable number of channels per connection&quot;,&quot;fullTitle&quot;:&quot;Quota and Limits Tests Channel Limits should allow reasonable number of channels per connection&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:49,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const client = new TestClient();\nawait client.connect();\nclients.push(client);\nconst targetChannels = 25;\nlet successfulSubscriptions = 0;\nconsole.log(`Testing subscription to ${targetChannels} channels...`);\nfor (let i = 0; i &lt; targetChannels; i++) {\n    try {\n        const channelName = TestUtils.generateChannelName(`limit-test-${i}`);\n        await client.subscribe(channelName);\n        successfulSubscriptions++;\n    } catch (error) {\n        console.log(`Hit channel limit at ${successfulSubscriptions} channels: ${error.message}`);\n        break;\n    }\n}\n// Should be able to handle a reasonable number of channels\nexpect(successfulSubscriptions).to.be.greaterThan(10);\nconsole.log(`Successfully subscribed to ${successfulSubscriptions} channels`);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c1b3c8f7-ec8c-455f-a157-adab319f4532&quot;,&quot;parentUUID&quot;:&quot;016e6bca-f037-45b8-aace-c6eb73f24fc5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;4d9167ab-c1da-4b69-aeb3-788fcf5459be&quot;,&quot;c1b3c8f7-ec8c-455f-a157-adab319f4532&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:78,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:30000},{&quot;uuid&quot;:&quot;6797cf42-a820-4d8f-bfd0-7f23e6544a0e&quot;,&quot;title&quot;:&quot;Presence Channel Limits&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/quotas.test.js&quot;,&quot;file&quot;:&quot;/tests/quotas.test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should track presence members accurately&quot;,&quot;fullTitle&quot;:&quot;Quota and Limits Tests Presence Channel Limits should track presence members accurately&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2041,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = &#x27;presence-member-test&#x27;;\nconst memberCount = 5; // Reasonable number for testing\nconsole.log(`Adding ${memberCount} members to presence channel...`);\n\n// Create multiple clients and subscribe to the same presence channel\nfor (let i = 0; i &lt; memberCount; i++) {\n    const client = new TestClient();\n    await client.connect();\n    await client.subscribe(channelName);\n    clients.push(client);\n    \n    // Small delay to avoid overwhelming the server\n    await TestUtils.wait(200);\n}\n// Check member count on the last client (should see all members)\nawait TestUtils.wait(1000); // Wait for presence updates to propagate\n\nconst members = clients[clients.length - 1].getPresenceMembers(channelName);\nexpect(members).to.exist;\nconsole.log(`Presence channel has ${members.count} members`);\nexpect(members.count).to.equal(memberCount);&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;b3cc8320-f3e2-4d37-8efd-69d38c741d27&quot;,&quot;parentUUID&quot;:&quot;6797cf42-a820-4d8f-bfd0-7f23e6544a0e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should track member count accurately&quot;,&quot;fullTitle&quot;:&quot;Quota and Limits Tests Presence Channel Limits should track member count accurately&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:5044,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = &#x27;presence-count-test&#x27;;\nconst clientCount = 5;\n// Add clients one by one and verify count\nfor (let i = 0; i &lt; clientCount; i++) {\n    const client = new TestClient();\n    await client.connect();\n    await client.subscribe(channelName);\n    clients.push(client);\n    // Wait for presence update to propagate\n    await TestUtils.wait(500);\n    const members = client.getPresenceMembers(channelName);\n    expect(members.count).to.equal(i + 1);\n}\n// Remove clients and verify count decreases\nwhile (clients.length &gt; 0) {\n    const client = clients.pop();\n    await client.disconnect();\n    \n    // Wait for presence update\n    await TestUtils.wait(500);\n    if (clients.length &gt; 0) {\n        const members = clients[0].getPresenceMembers(channelName);\n        expect(members.count).to.equal(clients.length);\n    }\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;ffae0dbf-6f95-48e7-a69c-18a6ed7195b0&quot;,&quot;parentUUID&quot;:&quot;6797cf42-a820-4d8f-bfd0-7f23e6544a0e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;b3cc8320-f3e2-4d37-8efd-69d38c741d27&quot;,&quot;ffae0dbf-6f95-48e7-a69c-18a6ed7195b0&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:7085,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:30000},{&quot;uuid&quot;:&quot;41892a4a-a975-46ad-9bb3-1e6ce60e2fde&quot;,&quot;title&quot;:&quot;Message Size Limits&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/quotas.test.js&quot;,&quot;file&quot;:&quot;/tests/quotas.test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should accept messages within size limits&quot;,&quot;fullTitle&quot;:&quot;Quota and Limits Tests Message Size Limits should accept messages within size limits&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:11,&quot;state&quot;:&quot;failed&quot;,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = TestUtils.generateChannelName(&#x27;size-test&#x27;);\n\nconst client = new TestClient();\nawait client.connect();\nawait client.subscribe(channelName);\nclients.push(client);\n// Send reasonably sized message (50KB)\nconst largeData = {\n    message: &#x27;Large payload test&#x27;,\n    payload: TestUtils.generateLargePayload(50)\n};\nawait TestUtils.sendApiEvent({\n    channels: channelName,\n    event: &#x27;large-message-test&#x27;,\n    data: largeData\n});\n// Should not throw an error&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;Error: API event failed: 400 - {\&quot;error\&quot;:\&quot;Missing authentication query parameters\&quot;}&quot;,&quot;estack&quot;:&quot;Error: API event failed: 400 - {\&quot;error\&quot;:\&quot;Missing authentication query parameters\&quot;}\n    at TestUtils.sendApiEvent (lib/TestUtils.js:120:19)\n    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)\n    at async Context.&lt;anonymous&gt; (tests/quotas.test.js:294:13)&quot;},&quot;uuid&quot;:&quot;6ba5ebdc-40e8-4682-8c51-b4bab96aab59&quot;,&quot;parentUUID&quot;:&quot;41892a4a-a975-46ad-9bb3-1e6ce60e2fde&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should reject oversized messages&quot;,&quot;fullTitle&quot;:&quot;Quota and Limits Tests Message Size Limits should reject oversized messages&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2298,&quot;state&quot;:&quot;failed&quot;,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = TestUtils.generateChannelName(&#x27;oversize-test&#x27;);\n\n// Try to send message larger than limit (1MB+)\nconst oversizedData = {\n    payload: TestUtils.generateLargePayload(1100) // 1.1MB\n};\ntry {\n    await TestUtils.sendApiEvent({\n        channels: channelName,\n        event: &#x27;oversized-test&#x27;,\n        data: oversizedData\n    });\n    expect.fail(&#x27;Should have rejected oversized message&#x27;);\n} catch (error) {\n    expect(error.message).to.match(/413|payload.*large|size.*limit/i);\n}&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;AssertionError: expected &#x27;API event failed: 400 - {\&quot;error\&quot;:\&quot;Mis…&#x27; to match /413|payload.*large|size.*limit/i&quot;,&quot;estack&quot;:&quot;AssertionError: expected &#x27;API event failed: 400 - {\&quot;error\&quot;:\&quot;Mis…&#x27; to match /413|payload.*large|size.*limit/i\n    at Context.&lt;anonymous&gt; (tests/quotas.test.js:319:42)\n    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)&quot;},&quot;uuid&quot;:&quot;023161fc-d6a9-4984-b2d2-194085cd9cf5&quot;,&quot;parentUUID&quot;:&quot;41892a4a-a975-46ad-9bb3-1e6ce60e2fde&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should reject oversized client events&quot;,&quot;fullTitle&quot;:&quot;Quota and Limits Tests Message Size Limits should reject oversized client events&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2216,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = &#x27;private-size-test&#x27;;\n\nconst client = new TestClient();\nawait client.connect();\nawait client.subscribe(channelName);\nclients.push(client);\nconst largePayload = {\n    data: TestUtils.generateLargePayload(1100) // 1.1MB\n};\ntry {\n    await client.trigger(channelName, &#x27;oversized-client-event&#x27;, largePayload);\n    expect.fail(&#x27;Should have rejected oversized client event&#x27;);\n} catch (error) {\n    expect(error).to.be.an(&#x27;error&#x27;);\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;00c2f8dd-4401-4a93-b3d4-1bd7242008cb&quot;,&quot;parentUUID&quot;:&quot;41892a4a-a975-46ad-9bb3-1e6ce60e2fde&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;00c2f8dd-4401-4a93-b3d4-1bd7242008cb&quot;],&quot;failures&quot;:[&quot;6ba5ebdc-40e8-4682-8c51-b4bab96aab59&quot;,&quot;023161fc-d6a9-4984-b2d2-194085cd9cf5&quot;],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:4525,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:30000},{&quot;uuid&quot;:&quot;848b6f29-24db-421c-aaa3-0162066c7393&quot;,&quot;title&quot;:&quot;API Rate Limits&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/quotas.test.js&quot;,&quot;file&quot;:&quot;/tests/quotas.test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should enforce API rate limits and recover&quot;,&quot;fullTitle&quot;:&quot;Quota and Limits Tests API Rate Limits should enforce API rate limits and recover&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:24,&quot;state&quot;:&quot;failed&quot;,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = TestUtils.generateChannelName(&#x27;api-rate-test&#x27;);\nconst rateLimit = 20; // 20 requests per second configured\n\n// Step 1: Send requests up to the rate limit\nconsole.log(`Sending ${rateLimit} API requests within rate limit...`);\nlet successCount = 0;\nfor (let i = 0; i &lt; rateLimit; i++) {\n    try {\n        await TestUtils.sendApiEvent({\n            channels: channelName,\n            event: &#x27;api-rate-test&#x27;,\n            data: { id: i }\n        });\n        successCount++;\n    } catch (error) {\n        console.log(`Error within limit: ${error.message}`);\n    }\n}\n\nexpect(successCount).to.be.greaterThan(0);\n\n// Step 2: Try to exceed the rate limit\nconsole.log(&#x27;Testing API rate limit enforcement...&#x27;);\nlet rateLimitHit = false;\nconst excessRequests = 10;\nfor (let i = 0; i &lt; excessRequests; i++) {\n    try {\n        await TestUtils.sendApiEvent({\n            channels: channelName,\n            event: &#x27;api-over-limit&#x27;,\n            data: { id: `excess-${i}` }\n        });\n    } catch (error) {\n        if (error.message.includes(&#x27;429&#x27;)) {\n            rateLimitHit = true;\n            console.log(&#x27;Got expected 429 rate limit error&#x27;);\n            break;\n        }\n    }\n}\n\n// Step 3: Wait for rate limit to reset  \nconsole.log(&#x27;Waiting for API rate limit to reset...&#x27;);\nawait TestUtils.wait(1200);\n\n// Step 4: Confirm we can make API requests again\nconsole.log(&#x27;Testing API rate limit recovery...&#x27;);\nlet canRequestAgain = false;\ntry {\n    await TestUtils.sendApiEvent({\n        channels: channelName,\n        event: &#x27;api-after-reset&#x27;,\n        data: { test: true }\n    });\n    canRequestAgain = true;\n    console.log(&#x27;Successfully made API request after rate limit reset&#x27;);\n} catch (error) {\n    console.log(`Error after reset: ${error.message}`);\n}\n\nexpect(canRequestAgain).to.be.true;&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;AssertionError: expected +0 to be above +0&quot;,&quot;estack&quot;:&quot;AssertionError: expected +0 to be above +0\n    at Context.&lt;anonymous&gt; (tests/quotas.test.js:365:40)\n    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)&quot;,&quot;diff&quot;:&quot;&quot;},&quot;uuid&quot;:&quot;2c190339-09b6-43c4-bb7c-938f0a289c6b&quot;,&quot;parentUUID&quot;:&quot;848b6f29-24db-421c-aaa3-0162066c7393&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[],&quot;failures&quot;:[&quot;2c190339-09b6-43c4-bb7c-938f0a289c6b&quot;],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:24,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:30000},{&quot;uuid&quot;:&quot;ecbc1b0b-31fc-49ce-9afd-a9dca966d98c&quot;,&quot;title&quot;:&quot;Resource Cleanup&quot;,&quot;fullFile&quot;:&quot;/var/www/sockudo/test/integration/tests/quotas.test.js&quot;,&quot;file&quot;:&quot;/tests/quotas.test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should properly cleanup disconnected client resources&quot;,&quot;fullTitle&quot;:&quot;Quota and Limits Tests Resource Cleanup should properly cleanup disconnected client resources&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2008,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = TestUtils.generateChannelName(&#x27;cleanup-test&#x27;);\n\n// Create client and subscribe\nconst client = new TestClient();\nawait client.connect();\nawait client.subscribe(channelName);\n\nconst socketId = client.getSocketId();\nexpect(socketId).to.be.a(&#x27;string&#x27;);\n// Disconnect client\nawait client.disconnect();\n\n// Wait for server cleanup\nawait TestUtils.wait(2000);\n// Try to get channel info - should show 0 connections\ntry {\n    const channelInfo = await TestUtils.getChannelInfo({\n        channel: channelName,\n        info: [&#x27;subscription_count&#x27;]\n    });\n    \n    if (channelInfo.subscription_count !== undefined) {\n        expect(channelInfo.subscription_count).to.equal(0);\n    }\n} catch (error) {\n    // Channel might not exist anymore, which is also valid cleanup\n    expect(error.message).to.match(/404|not found/i);\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;28961afc-a916-4a1f-b1b7-46177e25a50e&quot;,&quot;parentUUID&quot;:&quot;ecbc1b0b-31fc-49ce-9afd-a9dca966d98c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should cleanup unused channels&quot;,&quot;fullTitle&quot;:&quot;Quota and Limits Tests Resource Cleanup should cleanup unused channels&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:3011,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const channelName = TestUtils.generateChannelName(&#x27;auto-cleanup&#x27;);\n\n// Create and immediately disconnect client\nconst client = new TestClient();\nawait client.connect();\nawait client.subscribe(channelName);\nawait client.disconnect();\n\n// Wait for server cleanup\nawait TestUtils.wait(3000);\n// Check if channel still exists\ntry {\n    const channels = await TestUtils.getChannels({\n        filter: { prefix: channelName }\n    });\n    \n    // Channel should either not exist or have 0 subscribers\n    const foundChannel = channels.channels &amp;&amp; channels.channels[channelName];\n    if (foundChannel) {\n        expect(foundChannel.subscription_count).to.equal(0);\n    }\n} catch (error) {\n    // Acceptable if channel was cleaned up\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;2508df64-ba37-4473-956e-fbbc528c6cf9&quot;,&quot;parentUUID&quot;:&quot;ecbc1b0b-31fc-49ce-9afd-a9dca966d98c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;28961afc-a916-4a1f-b1b7-46177e25a50e&quot;,&quot;2508df64-ba37-4473-956e-fbbc528c6cf9&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:5019,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:30000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:30000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:15000}],&quot;meta&quot;:{&quot;mocha&quot;:{&quot;version&quot;:&quot;10.8.2&quot;},&quot;mochawesome&quot;:{&quot;options&quot;:{&quot;quiet&quot;:false,&quot;reportFilename&quot;:&quot;test-report&quot;,&quot;saveHtml&quot;:true,&quot;saveJson&quot;:false,&quot;consoleReporter&quot;:&quot;spec&quot;,&quot;useInlineDiffs&quot;:false,&quot;code&quot;:true},&quot;version&quot;:&quot;7.1.3&quot;},&quot;marge&quot;:{&quot;options&quot;:{&quot;reportDir&quot;:&quot;reports&quot;,&quot;reportFilename&quot;:&quot;test-report&quot;,&quot;html&quot;:&quot;true&quot;,&quot;json&quot;:&quot;false&quot;},&quot;version&quot;:&quot;6.2.0&quot;}}}" data-config="{&quot;reportFilename&quot;:&quot;test-report&quot;,&quot;reportDir&quot;:&quot;reports&quot;,&quot;reportTitle&quot;:&quot;integration&quot;,&quot;reportPageTitle&quot;:&quot;Mochawesome Report&quot;,&quot;inline&quot;:false,&quot;inlineAssets&quot;:false,&quot;cdn&quot;:false,&quot;charts&quot;:false,&quot;enableCharts&quot;:false,&quot;code&quot;:true,&quot;enableCode&quot;:true,&quot;autoOpen&quot;:false,&quot;overwrite&quot;:true,&quot;timestamp&quot;:false,&quot;ts&quot;:false,&quot;showPassed&quot;:true,&quot;showFailed&quot;:true,&quot;showPending&quot;:true,&quot;showSkipped&quot;:false,&quot;showHooks&quot;:&quot;failed&quot;,&quot;saveJson&quot;:false,&quot;saveHtml&quot;:true,&quot;dev&quot;:false,&quot;assetsDir&quot;:&quot;reports/assets&quot;,&quot;htmlFile&quot;:&quot;/var/www/sockudo/test/integration/reports/test-report.html&quot;}"><div id="report"></div><script src="assets/app.js"></script></body></html>